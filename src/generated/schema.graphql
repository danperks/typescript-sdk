input AcceptWorkspaceInviteInput {
  inviteId: ID!
}

type AcceptWorkspaceInviteOutput {
  error: MutationError
  invite: WorkspaceInvite
}

union Actor = CustomerActor | DeletedCustomerActor | MachineUserActor | SystemActor | UserActor

type ActorConnection {
  edges: [ActorEdge!]!
  pageInfo: PageInfo!
}

type ActorEdge {
  cursor: String!
  node: Actor!
}

input AddAdditionalAssigneesInput {
  machineUserIds: [ID!]
  threadId: ID!
  userIds: [ID!]
}

type AddAdditionalAssigneesOutput {
  error: MutationError
  thread: Thread
}

input AddCustomerToCustomerGroupsInput {
  customerGroupIdentifiers: [CustomerGroupIdentifier!]!
  customerId: ID!
}

type AddCustomerToCustomerGroupsOutput {
  customerGroupMemberships: [CustomerGroupMembership!]
  error: MutationError
}

input AddCustomerToTenantsInput {
  customerIdentifier: CustomerIdentifierInput!
  tenantIdentifiers: [TenantIdentifierInput!]!
}

type AddCustomerToTenantsOutput {
  customer: Customer
  error: MutationError
}

input AddGeneratedReplyInput {
  markdown: String!
  threadId: ID!
  timelineEntryId: ID!
}

type AddGeneratedReplyOutput {
  error: MutationError
  generatedReply: GeneratedReply
}

input AddLabelsInput {
  labelTypeIds: [ID!]!
  threadId: ID!
}

type AddLabelsOutput {
  error: MutationError
  labels: [Label!]!
  thread: Thread
}

input AddLabelsToUserInput {
  entityId: ID!
  labelTypeIds: [ID!]!
}

type AddLabelsToUserOutput {
  error: MutationError
  labels: [Label!]!
  user: User
}

input AddMembersToTierInput {
  memberIdentifiers: [TierMemberIdentifierInput!]!
  tierIdentifier: TierIdentifierInput!
}

type AddMembersToTierOutput {
  error: MutationError
  memberships: [TierMembership!]!
}

input AddUserToActiveBillingRotaInput {
  userId: ID!
}

type AddUserToActiveBillingRotaOutput {
  billingRota: BillingRota
  error: MutationError
}

input AddWorkspaceAlternateSupportEmailAddressInput {
  alternateSupportEmailAddress: String!
}

type AddWorkspaceAlternateSupportEmailAddressOutput {
  error: MutationError
  workspaceEmailDomainSettings: WorkspaceEmailDomainSettings
}

type ApiKey {
  createdAt: DateTime!
  createdBy: InternalActor!
  deletedAt: DateTime
  deletedBy: Actor
  description: String
  id: ID!
  isDeleted: Boolean!
  permissions: [String!]!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type ApiKeyConnection {
  edges: [ApiKeyEdge!]!
  pageInfo: PageInfo!
}

type ApiKeyEdge {
  cursor: String!
  node: ApiKey!
}

input ArchiveLabelTypeInput {
  labelTypeId: ID!
}

type ArchiveLabelTypeOutput {
  error: MutationError
  labelType: LabelType
}

input AssignRolesToUserInput {
  roleIds: [ID!] @deprecated(reason: "Use roleKey instead.")
  roleKey: RoleKey
  userId: ID!
  usingBillingRotaSeat: BooleanInput
}

type AssignRolesToUserOutput {
  error: MutationError
}

input AssignThreadInput {
  machineUserId: ID
  threadId: ID!
  userId: ID
}

type AssignThreadOutput {
  error: MutationError
  thread: Thread
}

type Attachment {
  createdAt: DateTime!
  createdBy: Actor!
  fileExtension: String
  fileMimeType: String!
  fileName: String!
  fileSize: FileSize!
  id: ID!
  type: AttachmentType!
  updatedAt: DateTime!
  updatedBy: Actor!
}

type AttachmentDownloadUrl {
  attachment: Attachment!
  downloadUrl: String!
  expiresAt: DateTime!
}

enum AttachmentType {
  CHAT
  CUSTOM_TIMELINE_ENTRY
  DISCORD
  EMAIL
  MS_TEAMS
  NOTE
  SLACK
  THREAD_DISCUSSION
}

type AttachmentUploadUrl {
  attachment: Attachment!
  expiresAt: DateTime!
  uploadFormData: [UploadFormData!]!
  uploadFormUrl: String!
}

enum AttachmentVirusScanResult {
  """The attachment is clean and safe to download."""
  CLEAN

  """The virus scan failed."""
  FAILED

  """The attachment is infected and should not be downloaded."""
  INFECTED

  """The virus scan is still pending."""
  PENDING
}

type Autoresponder {
  conditions: [AutoresponderCondition!]!
  createdAt: DateTime!
  createdBy: InternalActor!
  id: ID!
  isEnabled: Boolean!
  markdownContent: String
  messageSources: [AutoresponderMessageSource!]!
  name: String!
  order: Int!
  responseDelaySeconds: Int!
  textContent: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type AutoresponderBusinessHoursCondition {
  isOutsideBusinessHours: Boolean!
}

union AutoresponderCondition = AutoresponderBusinessHoursCondition | AutoresponderLabelCondition | AutoresponderPrioritiesCondition | AutoresponderSupportEmailsCondition | AutoresponderTierCondition

input AutoresponderConditionInput {
  isOutsideBusinessHours: Boolean
  labelTypeIds: [ID!]
  priorities: [Int!]
  supportEmailAddresses: [String!]
  tierId: ID
}

type AutoresponderConnection {
  edges: [AutoresponderEdge!]!
  pageInfo: PageInfo!
}

type AutoresponderEdge {
  cursor: String!
  node: Autoresponder!
}

type AutoresponderLabelCondition {
  labelTypeIds: [ID!]!
}

enum AutoresponderMessageSource {
  API
  CHAT
  DISCORD
  EMAIL
  MS_TEAMS
  SLACK
}

input AutoresponderOrderInput {
  autoresponderId: ID!
  order: Int!
}

type AutoresponderPrioritiesCondition {
  priorities: [Int!]!
}

type AutoresponderSupportEmailsCondition {
  supportEmailAddresses: [String!]!
}

type AutoresponderTierCondition {
  tierId: ID!
}

type BeforeBreachAction {
  beforeBreachMinutes: Int!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

input BeforeBreachActionInput {
  beforeBreachMinutes: Int!
}

interface BillingFeatureEntitlement {
  feature: FeatureKey!
  isEntitled: Boolean!
}

enum BillingInterval {
  MONTH @deprecated(reason: "Use BillingIntervalUnit.MONTH instead")
  YEAR @deprecated(reason: "Use BillingIntervalUnit.YEAR instead")
}

enum BillingIntervalUnit {
  MONTH
  YEAR
}

type BillingPlan {
  description: String!
  features: [String!]!
  highlightedLabel: String
  isSelfCheckoutEligible: Boolean!
  key: BillingPlanKey!
  monthlyPrice: Price @deprecated(reason: "Use prices instead")
  name: String!
  prices: [RecurringPrice!]!
  yearlyPrice: Price @deprecated(reason: "Use prices instead")
}

type BillingPlanChangePreview {
  earliestEffectiveAt: DateTime!
  immediateCost: Price!
}

type BillingPlanConnection {
  edges: [BillingPlanEdge!]!
  pageInfo: PageInfo!
}

type BillingPlanEdge {
  cursor: String!
  node: BillingPlan!
}

enum BillingPlanKey {
  EVALUATE
  GROW
  LAUNCH
  LEGACY
  SCALE
}

type BillingRota {
  offRotaUserIds: [ID!]!
  onRotaUserIds: [ID!]!
}

enum BillingSeatType {
  ENG_ROTA @deprecated
  MEMBER @deprecated
  VIEWER @deprecated
}

type BillingSubscription {
  cancelsAt: DateTime
  endedAt: DateTime
  entitlements: [BillingFeatureEntitlement!]!
  interval: BillingInterval! @deprecated
  planKey: BillingPlanKey!
  planName: String!
  status: BillingSubscriptionStatus!
  trialEndsAt: DateTime
}

enum BillingSubscriptionStatus {
  ACTIVE
  INACTIVE
}

input BooleanInput {
  value: Boolean!
}

"""A boolean setting"""
type BooleanSetting {
  """
  The value of the setting. This is named uniquely (instead of just `value`) so that the union has unique fields.
  """
  booleanValue: Boolean!

  """The setting code."""
  code: String!

  """The scope of the setting."""
  scope: SettingScope!
}

union BreachAction = BeforeBreachAction

input BreachActionInput {
  beforeBreachAction: BeforeBreachActionInput
}

input BulkJoinSlackChannelsInput {
  integrationId: ID!
}

type BulkJoinSlackChannelsOutput {
  error: MutationError
}

type BulkUpsertThreadFieldResult {
  result: UpsertResult
  threadField: ThreadField
}

input BulkUpsertThreadFieldsInput {
  inputs: [UpsertThreadFieldInput!]!
}

type BulkUpsertThreadFieldsOutput {
  error: MutationError
  results: [BulkUpsertThreadFieldResult!]!
}

"""
Represents the times in which you are open for business during a week. If a day is null, it means that day you are not
open for business.
"""
type BusinessHours {
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  weekDays: BusinessHoursWeekDays!
}

type BusinessHoursSlot {
  closesAt: String!
  opensAt: String!
  timezone: Timezone!
  weekday: WeekDay!
}

input BusinessHoursSlotInput {
  closesAt: String!
  opensAt: String!
  timezone: String!
  weekday: WeekDay!
}

type BusinessHoursWeekDay {
  endTime: Time!
  startTime: Time!
}

input BusinessHoursWeekDayInput {
  """
  The time you close for business on this day as an UTC ISO time. For example: 17:00Z .
  """
  endTime: String!

  """
  The time you open for business on this day as an UTC ISO time. For example: 09:00Z .
  """
  startTime: String!
}

type BusinessHoursWeekDays {
  friday: BusinessHoursWeekDay
  monday: BusinessHoursWeekDay
  saturday: BusinessHoursWeekDay
  sunday: BusinessHoursWeekDay
  thursday: BusinessHoursWeekDay
  tuesday: BusinessHoursWeekDay
  wednesday: BusinessHoursWeekDay
}

"""
Represents the times in which you are open for business during a week. Only provide the days you are open for business.
"""
input BusinessHoursWeekDaysInput {
  friday: BusinessHoursWeekDayInput
  monday: BusinessHoursWeekDayInput
  saturday: BusinessHoursWeekDayInput
  sunday: BusinessHoursWeekDayInput
  thursday: BusinessHoursWeekDayInput
  tuesday: BusinessHoursWeekDayInput
  wednesday: BusinessHoursWeekDayInput
}

input CalculateRoleChangeCostInput {
  quantity: IntInput
  roleKey: RoleKey!
  userId: ID
  usingBillingRotaSeat: BooleanInput
}

type CalculateRoleChangeCostOutput {
  error: MutationError
  roleChangeCost: RoleChangeCost
}

input ChangeBillingPlanInput {
  intervalUnit: BillingIntervalUnit
  planKey: BillingPlanKey!
}

type ChangeBillingPlanOutput {
  error: MutationError
}

input ChangeThreadCustomerInput {
  customerId: ID!
  threadId: ID!
}

type ChangeThreadCustomerOutput {
  error: MutationError
  thread: Thread
}

input ChangeThreadPriorityInput {
  priority: Int!
  threadId: ID!
}

type ChangeThreadPriorityOutput {
  error: MutationError
  thread: Thread
}

enum ChangeType {
  ADDED
  REMOVED
  UPDATED
}

input ChangeUserStatusInput {
  status: UserStatus!
  userId: ID!
}

type ChangeUserStatusOutput {
  error: MutationError
  user: User
}

type Chat {
  attachments: [Attachment!]!
  createdAt: DateTime!
  createdBy: Actor!
  customerReadAt: DateTime
  id: ID!
  text: String
  updatedAt: DateTime!
  updatedBy: Actor!
}

type ChatApp {
  createdAt: DateTime!
  createdBy: InternalActor!
  id: ID!
  logo: WorkspaceFile
  name: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type ChatAppConnection {
  edges: [ChatAppEdge!]!
  pageInfo: PageInfo!
}

type ChatAppEdge {
  cursor: String!
  node: ChatApp!
}

type ChatAppHiddenSecret {
  chatAppId: ID!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type ChatAppSecret {
  chatAppId: ID!
  createdAt: DateTime!
  createdBy: InternalActor!
  secret: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type ChatEntry {
  attachments: [Attachment!]!
  chatId: ID!
  customerReadAt: DateTime
  text: String
}

type ChatThreadChannelDetails {
  customerReadAt: DateTime!
}

input CompaniesFilter {
  companyIds: [ID!]

  """
  True to only return companies that have been deleted. False to only return companies that have not been deleted.
  Omit to return all companies.
  """
  isDeleted: Boolean
}

"""Query to search for companies."""
input CompaniesSearchQuery {
  """
  The term to search for. It must be at least 2 characters long. The search is case-insensitive on these two fields:
  - the company name (partial match)
  - the company domain name (partial match)
  """
  term: String!
}

type Company {
  accountOwner: User
  contractValue: Int
  createdAt: DateTime!
  createdBy: InternalActor!
  deletedAt: DateTime
  deletedBy: InternalActor
  domainName: String!
  id: ID!
  isDeleted: Boolean!
  logoUrl(size: Int): String
  name: String!
  threadChannelAssociations: [ThreadChannelAssociation!]!
  tier: Tier
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type CompanyConnection {
  edges: [CompanyEdge!]!
  pageInfo: PageInfo!
}

type CompanyEdge {
  cursor: String!
  node: Company!
}

input CompanyIdentifierInput {
  """
  The domain name of the company (e.g. plain.com). Alternatively, you can provide a full URL (e.g. https://www.plain.com) and we will do our best to extract the domain name.
  """
  companyDomainName: String

  """Plain's internal identifier for the company."""
  companyId: ID
}

type CompanySearchResult {
  company: Company!
}

type CompanySearchResultConnection {
  edges: [CompanySearchResultEdge!]!
  pageInfo: PageInfo!
}

type CompanySearchResultEdge {
  cursor: String!
  node: CompanySearchResult!
}

type CompanyTierMembership {
  companyId: ID!
  createdAt: DateTime!
  createdBy: InternalActor!
  id: ID!
  tierId: ID!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

input CompleteJiraAuthorizationInput {
  refreshToken: String!
  siteId: String!
}

input CompleteServiceAuthorizationInput {
  jira: CompleteJiraAuthorizationInput

  """JSON-encoded payload of the service configuration."""
  payload: String
  serviceAuthorizationId: ID!
}

type CompleteServiceAuthorizationOutput {
  error: MutationError
  serviceAuthorization: ServiceAuthorization
}

type ComponentBadge {
  badgeColor: ComponentBadgeColor
  badgeLabel: String!
}

enum ComponentBadgeColor {
  BLUE
  GREEN
  GREY
  RED
  YELLOW
}

input ComponentBadgeInput {
  badgeColor: ComponentBadgeColor

  """The label of the badge. Maximum 500 characters."""
  badgeLabel: String!
}

type ComponentContainer {
  containerContent: [ComponentContainerContent!]!
}

union ComponentContainerContent = ComponentBadge | ComponentCopyButton | ComponentDivider | ComponentLinkButton | ComponentPlainText | ComponentRow | ComponentSpacer | ComponentText

input ComponentContainerContentInput {
  componentBadge: ComponentBadgeInput
  componentCopyButton: ComponentCopyButtonInput
  componentDivider: ComponentDividerInput
  componentLinkButton: ComponentLinkButtonInput
  componentPlainText: ComponentPlainTextInput
  componentRow: ComponentRowInput
  componentSpacer: ComponentSpacerInput
  componentText: ComponentTextInput
}

input ComponentContainerInput {
  """Must contain at least one component."""
  containerContent: [ComponentContainerContentInput!]!
}

type ComponentCopyButton {
  copyButtonTooltipLabel: String
  copyButtonValue: String!
}

input ComponentCopyButtonInput {
  """The tooltip label. Maximum 500 characters."""
  copyButtonTooltipLabel: String

  """The value to be copied. Maximum 1000 characters."""
  copyButtonValue: String!
}

type ComponentDivider {
  dividerSpacingSize: ComponentDividerSpacingSize
  spacingSize: ComponentDividerSpacingSize @deprecated(reason: "use dividerSpacingSize instead")
}

input ComponentDividerInput {
  dividerSpacingSize: ComponentDividerSpacingSize
  spacingSize: ComponentDividerSpacingSize @deprecated(reason: "use dividerSpacingSize instead")
}

enum ComponentDividerSpacingSize {
  L
  M
  S
  XL
  XS
}

input ComponentInput {
  componentBadge: ComponentBadgeInput
  componentContainer: ComponentContainerInput
  componentCopyButton: ComponentCopyButtonInput
  componentDivider: ComponentDividerInput
  componentLinkButton: ComponentLinkButtonInput
  componentPlainText: ComponentPlainTextInput
  componentRow: ComponentRowInput
  componentSpacer: ComponentSpacerInput
  componentText: ComponentTextInput
}

type ComponentLinkButton {
  label: String! @deprecated(reason: "use linkButtonLabel instead")
  linkButtonLabel: String!
  linkButtonUrl: String!
  url: String! @deprecated(reason: "use linkButtonUrl instead")
}

input ComponentLinkButtonInput {
  label: String @deprecated(reason: "use linkButtonLabel instead")

  """The label of the button. Maximum 500 characters."""
  linkButtonLabel: String

  """Must be a valid URL."""
  linkButtonUrl: String
  url: String @deprecated(reason: "use linkButtonUrl instead")
}

type ComponentPlainText {
  plainText: String!
  plainTextColor: ComponentPlainTextColor
  plainTextSize: ComponentPlainTextSize
}

enum ComponentPlainTextColor {
  ERROR
  MUTED
  NORMAL
  SUCCESS
  WARNING
}

input ComponentPlainTextInput {
  """
  The text content, without markdown support. Must be between 1 and 5000 characters.
  """
  plainText: String!
  plainTextColor: ComponentPlainTextColor
  plainTextSize: ComponentPlainTextSize
}

enum ComponentPlainTextSize {
  L
  M
  S
}

type ComponentRow {
  rowAsideContent: [ComponentRowContent!]!
  rowMainContent: [ComponentRowContent!]!
}

union ComponentRowContent = ComponentBadge | ComponentCopyButton | ComponentDivider | ComponentLinkButton | ComponentPlainText | ComponentSpacer | ComponentText

input ComponentRowContentInput {
  componentBadge: ComponentBadgeInput
  componentCopyButton: ComponentCopyButtonInput
  componentDivider: ComponentDividerInput
  componentLinkButton: ComponentLinkButtonInput
  componentPlainText: ComponentPlainTextInput
  componentSpacer: ComponentSpacerInput
  componentText: ComponentTextInput
}

input ComponentRowInput {
  rowAsideContent: [ComponentRowContentInput!]!

  """Must contain at least one component."""
  rowMainContent: [ComponentRowContentInput!]!
}

type ComponentSpacer {
  size: ComponentSpacerSize! @deprecated(reason: "Use spacerSize instead, which has the same type")
  spacerSize: ComponentSpacerSize!
}

input ComponentSpacerInput {
  size: ComponentSpacerSize @deprecated(reason: "use spacerSize instead")

  """
  Required input, will be made required after deprecated fields are removed.
  """
  spacerSize: ComponentSpacerSize
}

enum ComponentSpacerSize {
  L
  M
  S
  XL
  XS
}

type ComponentText {
  color: ComponentTextColor @deprecated(reason: "Use textColor instead, which has the same type")
  size: ComponentTextSize @deprecated(reason: "Use textSize instead, which has the same type")
  text: String!
  textColor: ComponentTextColor
  textSize: ComponentTextSize
}

enum ComponentTextColor {
  ERROR
  MUTED
  NORMAL
  SUCCESS
  WARNING
}

input ComponentTextInput {
  color: ComponentTextColor @deprecated(reason: "use textColor instead")
  size: ComponentTextSize @deprecated(reason: "use textSize instead")

  """
  The text content, with markdown support. Must be between 1 and 5000 characters.
  """
  text: String!
  textColor: ComponentTextColor
  textSize: ComponentTextSize
}

enum ComponentTextSize {
  L
  M
  S
}

type ConnectedDiscordChannel {
  createdAt: DateTime!
  createdBy: InternalActor!
  discordChannelId: String!
  discordGuildId: String!
  id: ID!
  isEnabled: Boolean!
  name: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type ConnectedDiscordChannelConnection {
  edges: [ConnectedDiscordChannelEdge!]!
  pageInfo: PageInfo!
}

type ConnectedDiscordChannelEdge {
  cursor: String!
  node: ConnectedDiscordChannel!
}

type ConnectedMSTeamsChannel {
  createdAt: DateTime!
  createdBy: InternalActor!
  id: ID!
  msTeamsChannelId: ID!
  msTeamsTeamId: ID!
  msTeamsTenantId: ID!
  name: String!
  teamName: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  workspaceId: ID!
}

type ConnectedMSTeamsChannelConnection {
  edges: [ConnectedMSTeamsChannelEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ConnectedMSTeamsChannelEdge {
  cursor: String!
  node: ConnectedMSTeamsChannel!
}

type ConnectedSlackChannel {
  channelType: ConnectedSlackChannelType!
  createdAt: DateTime!
  createdBy: InternalActor!
  id: ID!
  isEnabled: Boolean!
  isPrivate: Boolean!
  name: String!
  slackChannelId: String!
  slackTeamId: String!
  threadChannelAssociations: [SlackThreadChannelAssociation!]!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type ConnectedSlackChannelConnection {
  edges: [ConnectedSlackChannelEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ConnectedSlackChannelEdge {
  cursor: String!
  node: ConnectedSlackChannel!
}

enum ConnectedSlackChannelType {
  """A channel that Plain tracks for customer support requests."""
  CUSTOMER

  """A channel that Plain tracks for internal team discussions."""
  DISCUSSION
}

input ConnectedSlackChannelsFilter {
  channelTypes: [ConnectedSlackChannelType!]
  isEnabled: BooleanInput
  slackTeamIds: [String!]
}

input CreateApiKeyInput {
  description: String
  machineUserId: ID!
  permissions: [String!]!
}

type CreateApiKeyOutput {
  apiKey: ApiKey
  apiKeySecret: String
  error: MutationError
}

input CreateAttachmentDownloadUrlInput {
  attachmentId: ID!
}

type CreateAttachmentDownloadUrlOutput {
  attachmentDownloadUrl: AttachmentDownloadUrl

  """
  The result of the virus scan on this attachment. If this is null, it means that your workspace does not have virus scan checks enabled.
  """
  attachmentVirusScanResult: AttachmentVirusScanResult
  error: MutationError
}

input CreateAttachmentUploadUrlInput {
  attachmentType: AttachmentType!
  customerId: ID!
  fileName: String!
  fileSizeBytes: Int!
}

type CreateAttachmentUploadUrlOutput {
  attachmentUploadUrl: AttachmentUploadUrl
  error: MutationError
}

input CreateAutoresponderInput {
  conditions: [AutoresponderConditionInput!]!
  isEnabled: Boolean!
  markdownContent: String
  messageSources: [AutoresponderMessageSource!]!
  name: String!
  order: Int!
  responseDelaySeconds: Int
  textContent: String!
}

type CreateAutoresponderOutput {
  autoresponder: Autoresponder
  error: MutationError
}

type CreateBillingPortalSessionOutput {
  billingPortalSessionUrl: String
  error: MutationError
}

input CreateChatAppInput {
  logo: WorkspaceFileInput
  name: String!
}

type CreateChatAppOutput {
  chatApp: ChatApp
  error: MutationError
}

input CreateChatAppSecretInput {
  chatAppId: ID!
}

type CreateChatAppSecretOutput {
  chatAppSecret: ChatAppSecret
  error: MutationError
}

input CreateCheckoutSessionInput {
  interval: BillingInterval @deprecated(reason: "Use intervalUnit instead")
  intervalUnit: BillingIntervalUnit
  plan: BillingPlanKey!
}

type CreateCheckoutSessionOutput {
  error: MutationError
  sessionClientSecret: String
}

"""
Input type to create a new customer card config.

By default new customer cards will have an ordering of 100000 (to place them at the bottom).
"""
input CreateCustomerCardConfigInput {
  """An array of headers name-value pairs (maximum length of array: 20)."""
  apiHeaders: [CustomerCardConfigApiHeaderInput!]!

  """
  The URL from which this card should be loaded (must start with `https://` and be a valid URL, max length: 600 characters).
  """
  apiUrl: String!

  """
  The default time the card should be cached for if no TTL is provided in the card response. (minimum: 15 seconds, maximum: 1 year or  31,536,000 seconds).
  """
  defaultTimeToLiveSeconds: Int!

  """
  The key of the card (must be unique in a workspace, max length: 500 characters, must match regex: `[a-zA-Z0-9_-]+`).
  """
  key: String!

  """The title of the card (max length: 500 characters)."""
  title: String!
}

type CreateCustomerCardConfigOutput {
  """The created customer card config."""
  customerCardConfig: CustomerCardConfig
  error: MutationError
}

input CreateCustomerEventInput {
  """The components used to create the event's contents."""
  components: [EventComponentInput!]!

  """The customer id of the customer that the event is for."""
  customerIdentifier: CustomerIdentifierInput!

  """
  The external ID of this event. You can use this field to store your own unique identifier for this event. This must be unique.
  """
  externalId: ID

  """
  When provided, this will override the timestamp of the event. Useful when backfilling events. Must be in ISO 8601 format (e.g. 2024-10-28T18:30:00Z).
  """
  timestamp: String

  """The title of the event."""
  title: String!
}

type CreateCustomerEventOutput {
  customerEvent: CustomerEvent
  error: MutationError
}

input CreateCustomerGroupInput {
  color: String!
  externalId: String
  key: String!
  name: String!
}

type CreateCustomerGroupOutput {
  customerGroup: CustomerGroup
  error: MutationError
}

input CreateCustomerSurveyInput {
  conditions: [CustomerSurveyConditionInput!]
  customerIntervalDays: Int
  isEnabled: Boolean!
  name: String!
  order: Int
  responseDelayMinutes: Int
  template: CustomerSurveyTemplateInput!
}

type CreateCustomerSurveyOutput {
  customerSurvey: CustomerSurvey
  error: MutationError
}

input CreateEmailPreviewUrlInput {
  customerId: ID!
  emailId: ID!
}

type CreateEmailPreviewUrlOutput {
  emailPreviewUrl: EmailPreviewUrl
  error: MutationError
}

input CreateEscalationPathInput {
  description: String
  name: String!
  steps: [EscalationPathStepInput!]!
}

type CreateEscalationPathOutput {
  error: MutationError
  escalationPath: EscalationPath
}

input CreateGithubUserAuthIntegrationInput {
  nangoConnectionId: String!
  nangoSessionToken: String!
}

type CreateGithubUserAuthIntegrationOutput {
  error: MutationError
  integration: GithubUserAuthIntegration
}

input CreateHelpCenterArticleGroupInput {
  helpCenterId: ID!
  name: String!

  """Parent group ID. If not provided, creates a top-level group."""
  parentHelpCenterArticleGroupId: ID
  slug: String
}

type CreateHelpCenterArticleGroupOutput {
  error: MutationError
  helpCenterArticleGroup: HelpCenterArticleGroup
}

input CreateHelpCenterInput {
  authMechanism: HelpCenterAuthMechanismInput
  bodyCustomJs: String
  color: String
  description: String!
  favicon: HelpCenterThemedImageInput
  headCustomJs: String
  internalName: String!
  isChatEnabled: Boolean
  logo: HelpCenterThemedImageInput
  publicName: String!
  socialPreviewImage: WorkspaceFileInput
  subdomain: String!
  type: HelpCenterType!
}

type CreateHelpCenterOutput {
  error: MutationError
  helpCenter: HelpCenter
}

input CreateIndexedDocumentInput {
  knowledgeSourceId: ID!
  labelTypeIds: [ID!]
  url: String!
}

type CreateIndexedDocumentOutput {
  error: MutationError
  indexedDocument: IndexedDocument
}

input CreateIssueTrackerIssueInput {
  description: String
  fields: [IssueTrackerFieldInput!]!
  issueTrackerType: String!
  title: String!
}

type CreateIssueTrackerIssueOutput {
  error: MutationError
  threadLinkCandidate: ThreadLinkCandidate
}

input CreateKnowledgeSourceInput {
  labelTypeIds: [ID!]
  type: KnowledgeSourceType!
  url: String!
}

type CreateKnowledgeSourceOutput {
  error: MutationError
  knowledgeSource: KnowledgeSource
}

input CreateLabelTypeInput {
  color: String
  description: String
  icon: String
  name: String!
  parentLabelTypeId: ID
  type: LabelTypeType
}

type CreateLabelTypeOutput {
  error: MutationError
  labelType: LabelType
}

input CreateMachineUserInput {
  avatar: WorkspaceFileInput
  description: String
  fullName: String!
  publicName: String!

  """The type of machine user. Defaults to API_USER if not specified."""
  type: MachineUserType
}

type CreateMachineUserOutput {
  error: MutationError
  machineUser: MachineUser
}

input CreateMyFavoritePageInput {
  key: String!
}

type CreateMyFavoritePageOutput {
  error: MutationError
  favoritePage: FavoritePage
}

input CreateMyLinearIntegrationInput {
  authCode: String!
  redirectUrl: String!
}

type CreateMyLinearIntegrationOutput {
  error: MutationError
  integration: UserLinearIntegration
}

input CreateMyMSTeamsIntegrationInput {
  authCode: ID!
  redirectUrl: String!
}

type CreateMyMSTeamsIntegrationOutput {
  error: MutationError
  integration: UserMSTeamsIntegration
}

input CreateMySlackIntegrationInput {
  authCode: String!
  redirectUrl: String!
}

type CreateMySlackIntegrationOutput {
  error: MutationError
  integration: UserSlackIntegration
}

input CreateNoteInput {
  attachmentIds: [ID!]
  customerId: ID!
  markdown: String
  text: String!
  threadId: ID
}

type CreateNoteOutput {
  error: MutationError
  note: Note
}

input CreateSavedThreadsViewInput {
  color: String!
  icon: String!
  name: String!
  threadsFilter: SavedThreadsViewFilterInput!
}

type CreateSavedThreadsViewOutput {
  error: MutationError
  savedThreadsView: SavedThreadsView
}

input CreateServiceLevelAgreementInput {
  serviceLevelAgreement: ServiceLevelAgreementInput!
  tierId: ID!
}

type CreateServiceLevelAgreementOutput {
  error: MutationError
  serviceLevelAgreement: ServiceLevelAgreement
}

input CreateSnippetInput {
  markdown: String
  name: String!

  """Used to group snippets, only accepts alphanumeric characters"""
  path: String
  text: String!
}

type CreateSnippetOutput {
  error: MutationError
  snippet: Snippet
}

"""Only one of the fields can be set."""
input CreateThreadAssignedToInput {
  machineUserId: ID
  userId: ID
}

input CreateThreadChannelAssociationInput {
  companyIdentifier: CompanyIdentifierInput!
  connectedSlackChannelId: ID
}

type CreateThreadChannelAssociationOutput {
  error: MutationError
  threadChannelAssociation: ThreadChannelAssociation
}

input CreateThreadDiscussionInput {
  emailDetails: ThreadDiscussionEmailDetailsInput
  markdownContent: String!
  slackDetails: ThreadDiscussionSlackDetailsInput
  threadId: ID!
  type: ThreadDiscussionType!
}

type CreateThreadDiscussionOutput {
  error: MutationError
  threadDiscussion: ThreadDiscussion
}

input CreateThreadEventInput {
  """The components used to create the event's contents."""
  components: [EventComponentInput!]!

  """
  The external ID of this event. You can use this field to store your own unique identifier for this event. This must be unique.
  """
  externalId: ID

  """The thread id of the thread that the event is for."""
  threadId: ID!

  """
  When provided, this will override the timestamp of the event. Useful when backfilling events. Must be in ISO 8601 format (e.g. 2024-10-28T18:30:00Z).
  """
  timestamp: String

  """The title of the event."""
  title: String!
}

type CreateThreadEventOutput {
  error: MutationError
  threadEvent: ThreadEvent
}

input CreateThreadFieldOnThreadInput {
  booleanValue: Boolean
  key: String!
  stringValue: String
  type: ThreadFieldSchemaType!
}

input CreateThreadFieldSchemaInput {
  defaultBooleanValue: Boolean
  defaultStringValue: String
  dependsOnLabelTypeIds: [ID!]
  dependsOnThreadField: DependsOnThreadFieldInput
  description: String!
  enumValues: [String!]!
  isAiAutoFillEnabled: Boolean!
  isRequired: Boolean!
  key: String!
  label: String!
  order: Int!
  type: ThreadFieldSchemaType!
}

type CreateThreadFieldSchemaOutput {
  error: MutationError
  threadFieldSchema: ThreadFieldSchema
}

input CreateThreadInput {
  """User or machine user this thread should be assigned to."""
  assignedTo: CreateThreadAssignedToInput

  """An array of attachments for the first timeline entry in the thread."""
  attachmentIds: [ID!] @deprecated(reason: "Use sendChat and sendCustomerChat mutations instead. Both allow you to backdate messages.")

  """
  The channel to create the thread for. Currently supported: API, EMAIL, SLACK, MS_TEAMS, or CHAT. Defaults to API.
  """
  channel: ThreadChannel

  """
  Channel details for the thread, required if channel is SLACK or MS_TEAMS
  """
  channelDetails: ThreadChannelDetailsInput

  """The components used to create the first timeline entry in the thread."""
  components: [ComponentInput!] @deprecated(reason: "Use sendChat and sendCustomerChat mutations instead. Both allow you to backdate messages.")

  """
  The identifier of the customer being either the existing customer ID, the customer's email address or and external ID.
  """
  customerIdentifier: CustomerIdentifierInput!

  """
  The optional description for this thread. This is used to display a preview of the thread in the UI.
  If not provided, we will automatically infer it from the components you provided.
  """
  description: String

  """
  The external ID of this thread. You can use this field to store your own unique identifier for this thread.
  """
  externalId: ID

  """An array of label types to attach to the thread upon creation."""
  labelTypeIds: [ID!]

  """
  The priority of the thread. Valid values are 0, 1, 2, 3, from most to least urgent, defaults to 2 (normal).
  """
  priority: Int

  """A thread may be assigned to a specific tenant."""
  tenantIdentifier: TenantIdentifierInput

  """An array of thread fields to attach to the thread upon creation."""
  threadFields: [CreateThreadFieldOnThreadInput!]

  """The title of the thread."""
  title: String
}

input CreateThreadLinkInput {
  jiraIssue: JiraIssueThreadLinkInput
  linearIssue: LinearIssueThreadLinkInput
  plainThread: PlainThreadLinkInput
  sourceId: String
  sourceType: String
  threadId: ID!
}

type CreateThreadLinkOutput {
  error: MutationError
  threadLink: ThreadLink
}

type CreateThreadOutput {
  error: MutationError
  thread: Thread
}

input CreateTierInput {
  """
  The color to assign to this tier, given by its hex code (e.g. #FABADA). This color is used in Plain's UI to represent this tier.
  """
  color: String!

  """
  Any thread created in this tier will have this priority by default, unless a different priority is specified while creating it. If not provided, it defaults to 2 (normal priority).
  """
  defaultThreadPriority: Int

  """
  The external ID of this tier. You can use this field to store your own unique identifier for this tier. This must be unique in your workspace.
  """
  externalId: String!

  """
  If set to true, this tier will be applied to all threads that do not match any other tier.
  
  Only one tier can be the default tier.
  
  Default: false
  """
  isDefault: Boolean
  memberIdentifiers: [TierMemberIdentifierInput!]!

  """The name of this tier."""
  name: String!
}

type CreateTierOutput {
  error: MutationError
  tier: Tier
}

input CreateUserAccountInput {
  fullName: String!
  marketingConsent: Boolean
  publicName: String!
}

type CreateUserAccountOutput {
  error: MutationError
  userAccount: UserAccount
}

input CreateUserAuthDiscordChannelIntegrationInput {
  authCode: String!
  discordGuildId: String!
  redirectUrl: String!
}

type CreateUserAuthDiscordChannelIntegrationOutput {
  error: MutationError
  integration: UserAuthDiscordChannelIntegration
}

input CreateUserAuthSlackIntegrationInput {
  authCode: String!
  redirectUrl: String!
}

type CreateUserAuthSlackIntegrationOutput {
  error: MutationError
  integration: UserAuthSlackIntegration
}

input CreateWebhookTargetInput {
  description: String!
  eventSubscriptions: [WebhookTargetEventSubscriptionInput!]!
  isEnabled: Boolean!
  url: String!
  version: String
}

type CreateWebhookTargetOutput {
  error: MutationError
  webhookTarget: WebhookTarget
}

input CreateWorkflowRuleInput {
  name: String!

  """JSON-encoded payload of the rule definition."""
  payload: String!
}

type CreateWorkflowRuleOutput {
  error: MutationError
  workflowRule: WorkflowRule
}

input CreateWorkspaceDiscordChannelIntegrationInput {
  authCode: String!
  redirectUrl: String!
}

type CreateWorkspaceDiscordChannelIntegrationOutput {
  error: MutationError
  integration: WorkspaceDiscordChannelIntegration
}

input CreateWorkspaceDiscordIntegrationInput {
  name: String!
  webhookUrl: String!
}

type CreateWorkspaceDiscordIntegrationOutput {
  error: MutationError
  integration: WorkspaceDiscordIntegration
}

input CreateWorkspaceEmailDomainSettingsInput {
  supportEmailAddress: String!
}

type CreateWorkspaceEmailDomainSettingsOutput {
  error: MutationError
  workspaceEmailDomainSettings: WorkspaceEmailDomainSettings
}

input CreateWorkspaceFileUploadUrlInput {
  fileName: String!
  fileSizeBytes: Int!
  visibility: WorkspaceFileVisibility!
}

type CreateWorkspaceFileUploadUrlOutput {
  error: MutationError
  workspaceFileUploadUrl: WorkspaceFileUploadUrl
}

input CreateWorkspaceInput {
  name: String!
  publicName: String!
}

input CreateWorkspaceMSTeamsIntegrationInput {
  msTeamsTenantId: ID!
}

type CreateWorkspaceMSTeamsIntegrationOutput {
  error: MutationError
  integration: WorkspaceMSTeamsIntegration
}

type CreateWorkspaceOutput {
  error: MutationError
  workspace: Workspace
}

input CreateWorkspaceSlackChannelIntegrationInput {
  authCode: String!
  redirectUrl: String!
}

type CreateWorkspaceSlackChannelIntegrationOutput {
  error: MutationError
  integration: WorkspaceSlackChannelIntegration
}

input CreateWorkspaceSlackIntegrationInput {
  authCode: String!
  redirectUrl: String!
}

type CreateWorkspaceSlackIntegrationOutput {
  error: MutationError
  integration: WorkspaceSlackIntegration
}

type CsatCustomerSurveyTemplate {
  questionText: String!
  type: String!
}

input CsatCustomerSurveyTemplateInput {
  questionText: String!
  type: String!
}

enum CurrencyCode {
  USD
}

type CustomEntry {
  attachments: [Attachment!]!
  components: [CustomTimelineEntryComponent!]!
  externalId: ID
  title: String!
  type: String
}

union CustomTimelineEntryComponent = ComponentBadge | ComponentContainer | ComponentCopyButton | ComponentDivider | ComponentLinkButton | ComponentPlainText | ComponentRow | ComponentSpacer | ComponentText

"""
The core customer entity. A customer only exists (ideally) once.
Uniqueness is guaranteed on both of these fields:
1. `externalId` if provided
2. `email`
"""
type Customer {
  """When the customer was assigned to a user."""
  assignedAt: DateTime

  """The user the customer is assigned to."""
  assignedToUser: UserActor

  """The avatar URL of the customer."""
  avatarUrl: String

  """The company the customer belongs to."""
  company: Company
  createdAt: DateTime!
  createdBy: Actor!

  """A subquery to fetch the customer's group memberships."""
  customerGroupMemberships(after: String, before: String, filters: CustomerGroupMembershipsFilter, first: Int, last: Int): CustomerGroupMembershipConnection!

  """The customer's email address."""
  email: EmailAddress!

  """Your system's ID for this customer."""
  externalId: ID

  """The full name of the customer."""
  fullName: String!

  """Uniquely identifies a customer in Plain."""
  id: ID!
  identities: [CustomerIdentity!]!
  isAnonymous: Boolean!
  lastIdleAt: DateTime @deprecated(reason: "Use Thread.statusChangedAt instead")
  markedAsSpamAt: DateTime
  markedAsSpamBy: InternalActor

  """An optional short name of the customer, typically their first name."""
  shortName: String
  status: CustomerStatus @deprecated(reason: "Use Thread.status instead")
  statusChangedAt: DateTime @deprecated(reason: "Use Thread.statusChangedAt instead")

  """A subquery to fetch the customer's tenants."""
  tenantMemberships(after: String, before: String, first: Int, last: Int): CustomerTenantMembershipConnection!
  updatedAt: DateTime!
  updatedBy: Actor!
}

type CustomerActor {
  customer: Customer!
  customerId: ID!
}

union CustomerCardComponent = ComponentBadge | ComponentContainer | ComponentCopyButton | ComponentDivider | ComponentLinkButton | ComponentPlainText | ComponentRow | ComponentSpacer | ComponentText

"""
The configuration of a customer card that defines four important things:

- The title of the card
- The key of the card, which will be used in the request payload to the API URL
- The order in which the cards should appear
- Which API the card should be loaded from (and the required authentication headers)

Configs that have the same API URL and API Headers will be loaded in batch. API header names are treated case insensitively.

A maximum of 25 customer cards can be configured.
"""
type CustomerCardConfig {
  """
  An array of headers name-value pairs (maximum length of array: 20). Requires the `customerCardConfigApiDetails:read` permission.
  """
  apiHeaders: [CustomerCardConfigApiHeader!]!

  """
  The URL from which this card should be loaded (must start with `https://` and be a valid URL, max length: 600 characters). Requires the `customerCardConfigApiDetails:read` permission.
  """
  apiUrl: String!
  createdAt: DateTime!
  createdBy: InternalActor!

  """
  The default time the card should be cached for if no TTL is provided in the card response. (minimum: 15 seconds, maximum: 1 year or  31,536,000 seconds).
  """
  defaultTimeToLiveSeconds: Int!

  """The ID of the customer card config."""
  id: ID!

  """
  Indicates if the customer card is enabled or not. Disabled customer card configs are not loaded or displayed for customers.
  """
  isEnabled: Boolean!

  """
  The key of the card (must be unique in a workspace, max length: 500 characters, must match regex: `[a-zA-Z0-9_-]+`).
  """
  key: String!

  """
  The order in which this customer card config should be shown.
  
  Duplicate order numbers are allowed, in case the order is the same they will be sorted based on `id`. The minimum is 0 and the maximum is 100000.
  """
  order: Int!

  """The title of the card (max length: 500 characters)."""
  title: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

"""An API header that will be sent to the configured API URL."""
type CustomerCardConfigApiHeader {
  """
  The name of the header, trimmed and treated case insensitively for deduplication purposes (min length: 1, max length: 100). Not all header names are allowed.
  """
  name: String!

  """
  The value of the header, treated case sensitively for deduplication purposes (min length: 1, max length: 500).
  """
  value: String!
}

"""An API header that will be sent to the configured API URL."""
input CustomerCardConfigApiHeaderInput {
  """
  The name of the header, trimmed and treated case insensitively for deduplication purposes (min length: 1, max length: 100). Not all header names are allowed.
  """
  name: String!

  """
  The value of the header, treated case sensitively for deduplication purposes (min length: 1, max length: 500).
  """
  value: String!
}

input CustomerCardConfigOrderInput {
  """The ID of the customer card config to be reordered."""
  customerCardConfigId: ID!

  """The order the customer card config should have."""
  order: Int!
}

"""
A shared interface for all common properties customer card instances can have.
A customer can only have one customer card instance for each customer card config at any point in time.

Has 3 implementations:
- `CustomerCardInstanceLoading`
- `CustomerCardInstanceLoaded`
- `CustomerCardInstanceError`
"""
interface CustomerCardInstance {
  createdAt: DateTime!
  createdBy: Actor!

  """The customer card config this instance is for."""
  customerCardConfig: CustomerCardConfig!

  """The customer the instance is for."""
  customerId: ID!

  """
  The ID of the customer card instance. A new ID is generated for each load.
  """
  id: ID!

  """
  The thread the instance is for. Null if this card is not loaded in a thread context.
  """
  threadId: ID
  updatedAt: DateTime!
  updatedBy: Actor!
}

"""The card exceeded the maximum allowed size."""
type CustomerCardInstanceCardTooBigErrorDetail {
  cardKey: String!
  maxSizeBytes: Int!
  message: String!
  sizeBytes: Int!
}

type CustomerCardInstanceChange {
  changeType: ChangeType!
  customerCardInstance: CustomerCardInstance!
}

union CustomerCardInstanceChangesResult = CustomerCardInstanceChange | SubscriptionAcknowledgement

type CustomerCardInstanceError implements CustomerCardInstance {
  createdAt: DateTime!
  createdBy: Actor!

  """The customer card config this instance is for."""
  customerCardConfig: CustomerCardConfig!

  """The customer the instance is for."""
  customerId: ID!

  """The details of the customer card load error."""
  errorDetail: CustomerCardInstanceErrorDetail!

  """
  The ID of the customer card instance. A new ID is generated for each load.
  """
  id: ID!

  """
  The thread the instance is for. Null if this card is not loaded in a thread context.
  """
  threadId: ID
  updatedAt: DateTime!
  updatedBy: Actor!
}

"""Details for the reasons why the customer card failed to load."""
union CustomerCardInstanceErrorDetail = CustomerCardInstanceCardTooBigErrorDetail | CustomerCardInstanceMissingCardErrorDetail | CustomerCardInstanceRequestErrorDetail | CustomerCardInstanceResponseBodyErrorDetail | CustomerCardInstanceStatusCodeErrorDetail | CustomerCardInstanceTimeoutErrorDetail | CustomerCardInstanceUnknownErrorDetail

"""A loaded customer card."""
type CustomerCardInstanceLoaded implements CustomerCardInstance {
  """
  The list of components of the customer card. If this is null it means the customer card was returned on the API, but the components array was empty.
  """
  components: [CustomerCardComponent!]
  createdAt: DateTime!
  createdBy: Actor!

  """The customer card config this instance is for."""
  customerCardConfig: CustomerCardConfig!

  """The customer the instance is for."""
  customerId: ID!
  expiresAt: DateTime!

  """
  The ID of the customer card instance. A new ID is generated for each load.
  """
  id: ID!

  """When the customer card was received from the API."""
  loadedAt: DateTime!

  """
  The thread the instance is for. Null if this card is not loaded in a thread context.
  """
  threadId: ID
  updatedAt: DateTime!
  updatedBy: Actor!
}

"""
A loading customer card. The createdAt timestamp indicates when the load was started.
Will be updated to be a CustomerCardInstanceLoaded or CustomerCardInstanceError.
"""
type CustomerCardInstanceLoading implements CustomerCardInstance {
  createdAt: DateTime!
  createdBy: Actor!

  """The customer card config this instance is for."""
  customerCardConfig: CustomerCardConfig!

  """The customer the instance is for."""
  customerId: ID!

  """
  The ID of the customer card instance. A new ID is generated for each load.
  """
  id: ID!

  """
  The thread the instance is for. Null if this card is not loaded in a thread context.
  """
  threadId: ID
  updatedAt: DateTime!
  updatedBy: Actor!
}

"""The configured API URL didn't return a requested card key."""
type CustomerCardInstanceMissingCardErrorDetail {
  cardKey: String!
  message: String!
}

"""Plain failed to make the request to the configured API URL."""
type CustomerCardInstanceRequestErrorDetail {
  errorCode: String!
  message: String!
}

"""An invalid response body was returned from the configured API URL."""
type CustomerCardInstanceResponseBodyErrorDetail {
  message: String!
  responseBody: String!
}

"""A non-200 status code was returned from the configured API URL."""
type CustomerCardInstanceStatusCodeErrorDetail {
  message: String!
  responseBody: String!
  statusCode: Int!
}

"""The card failed to load within the timeout."""
type CustomerCardInstanceTimeoutErrorDetail {
  message: String!
  timeoutSeconds: Int!
}

"""
An unknown error occurred. If this error is persistent, please contact our support.
"""
type CustomerCardInstanceUnknownErrorDetail {
  message: String!
}

type CustomerChange {
  changeType: ChangeType!
  customer: Customer!
}

input CustomerChangesFilter {
  assignedToUser: [ID!]
}

type CustomerConnection {
  edges: [CustomerEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CustomerEdge {
  cursor: String!
  node: Customer!
}

type CustomerEmailActor {
  customer: Customer!
  customerId: ID!
}

type CustomerEvent {
  """The list of components of the event."""
  components: [EventComponent!]!

  """The datetime when this event was created."""
  createdAt: DateTime!

  """The actor who created this event."""
  createdBy: Actor!

  """The customer that this event belongs to."""
  customerId: ID!

  """The ID of the event."""
  id: ID!

  """The title of the event."""
  title: String!

  """The datetime when this event was last updated."""
  updatedAt: DateTime!

  """The actor who last updated this event."""
  updatedBy: Actor!
}

type CustomerEventEntry implements TimelineEventEntry {
  components: [EventComponent!]!
  customerId: ID!
  externalId: ID
  timelineEventId: ID!
  title: String!
}

type CustomerGroup {
  color: String!
  createdAt: DateTime!
  createdBy: InternalActor!
  externalId: String
  id: ID!
  key: String!
  name: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type CustomerGroupConnection {
  edges: [CustomerGroupEdge!]!
  pageInfo: PageInfo!
}

type CustomerGroupEdge {
  cursor: String!
  node: CustomerGroup!
}

input CustomerGroupIdentifier {
  customerGroupId: ID
  customerGroupKey: String
  externalId: String
}

type CustomerGroupMembership {
  createdAt: DateTime!
  createdBy: InternalActor!
  customerGroup: CustomerGroup!
  customerId: ID!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type CustomerGroupMembershipConnection {
  edges: [CustomerGroupMembershipEdge!]!
  pageInfo: PageInfo!
}

type CustomerGroupMembershipEdge {
  cursor: String!
  node: CustomerGroupMembership!
}

input CustomerGroupMembershipsFilter {
  customerGroupExternalIds: [String!]
}

input CustomerGroupsFilter {
  externalIds: [String!]
}

"""Only one of the fields can be set."""
input CustomerIdentifierInput {
  customerId: ID
  emailAddress: String
  externalId: ID
}

union CustomerIdentity = DiscordCustomerIdentity | EmailCustomerIdentity | SlackCustomerIdentity

input CustomerImpersonationInput {
  customerIdentifier: CustomerIdentifierInput!
}

"""
The customer attributes available for search, each of them mapped to a search expression.
Exactly one of them must be provided in a single search condition.
"""
input CustomerSearchCondition {
  """Search expression on the customer's email address."""
  email: StringSearchExpression

  """Search expression on the customer's external id."""
  externalId: StringSearchExpression

  """Search expression on the customer's full name."""
  fullName: StringSearchExpression

  """Search expression on the customer's short name."""
  shortName: StringSearchExpression

  """
  Search expression on specific timeline entries' text (email, chat) sent or received by the customer.
  Common English stop-words will be removed from the text to search.
  """
  timelineEntryText: StringSearchExpression
}

type CustomerSearchConnection {
  edges: [CustomerSearchEdge!]!
  pageInfo: PageInfo!
}

type CustomerSearchEdge {
  cursor: String!
  node: Customer!
}

enum CustomerStatus {
  ACTIVE @deprecated(reason: "Use ThreadStatus.TODO instead")
  IDLE @deprecated(reason: "Use ThreadStatus.DONE instead")
  SNOOZED @deprecated(reason: "Use ThreadStatus.SNOOZED instead")
}

type CustomerSurvey {
  conditions: [CustomerSurveyCondition!]!
  createdAt: DateTime!
  createdBy: InternalActor!
  customerIntervalDays: Int!
  id: ID!
  isEnabled: Boolean!
  name: String!
  order: Int!
  responseDelayMinutes: Int!
  template: CustomerSurveyTemplate!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

union CustomerSurveyCondition = CustomerSurveyLabelCondition | CustomerSurveyMessageSourceCondition | CustomerSurveyPrioritiesCondition | CustomerSurveySupportEmailsCondition | CustomerSurveyTiersCondition

input CustomerSurveyConditionInput {
  labelTypeIds: [ID!]
  messageSource: [MessageSource!]
  priorities: [Int!]
  supportEmailAddresses: [String!]
  tierIds: [ID!]
}

type CustomerSurveyConnection {
  edges: [CustomerSurveyEdge!]!
  pageInfo: PageInfo!
}

type CustomerSurveyEdge {
  cursor: String!
  node: CustomerSurvey!
}

type CustomerSurveyLabelCondition {
  labelTypeIds: [ID!]!
}

type CustomerSurveyMessageSourceCondition {
  messageSource: [MessageSource!]!
}

input CustomerSurveyOrderInput {
  customerSurveyId: ID!
  order: Int!
}

type CustomerSurveyPrioritiesCondition {
  priorities: [Int!]!
}

type CustomerSurveySupportEmailsCondition {
  supportEmailAddresses: [String!]!
}

union CustomerSurveyTemplate = CsatCustomerSurveyTemplate

input CustomerSurveyTemplateInput {
  csatTemplate: CsatCustomerSurveyTemplateInput
}

type CustomerSurveyTiersCondition {
  tierIds: [ID!]!
}

type CustomerTenantMembership {
  createdAt: DateTime!
  createdBy: InternalActor!
  tenant: Tenant!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type CustomerTenantMembershipConnection {
  edges: [CustomerTenantMembershipEdge!]!
  pageInfo: PageInfo!
}

type CustomerTenantMembershipEdge {
  cursor: String!
  node: CustomerTenantMembership!
}

input CustomersFilter {
  """
  Filters customers to those belonging to the given companies.
  Customers who dont belong to any of the given companies will not be included.
  Can be combined with other company filters.
  """
  companyIdentifiers: [CompanyIdentifierInput!]

  """
  Filters customers to those with at least one of the given customer group IDs.
  Customers with no groups will not be included.
  Can be combined with other group filters.
  """
  customerGroupIds: [ID!]

  """
  Filters customers to those with at least one of the given customer group keys.
  Customers with no groups will not be included.
  Can be combined with other group filters.
  """
  customerGroupKeys: [String!]
  isMarkedAsSpam: Boolean

  """
  Filters customers to those belonging to the given tenants.
  Customers who dont belong to any of the given tenants will not be included.
  Can be combined with other company filters.
  """
  tenantIdentifiers: [TenantIdentifierInput!]
}

"""
A query to search for customers. Search queries are combinations of search conditions, as defined
below. At least one search condition must be provided.
"""
input CustomersSearchQuery {
  """
  An array of search conditions that will be combined using a 'logical OR' to search for customers.
  """
  or: [CustomerSearchCondition!]
}

input CustomersSort {
  direction: SortDirection!
  field: CustomersSortField!
}

enum CustomersSortField {
  FULL_NAME
}

type DateTime {
  iso8601: String!
  unixTimestamp: String!
}

input DatetimeFilter {
  """
  Timestamps -greater or equal- than this value. ISO 8601 format (e.g. 2024-10-28T18:30:00Z).
  """
  after: String

  """
  Timestamps -less- than this value. ISO 8601 format (e.g. 2024-10-28T18:30:00Z).
  """
  before: String
}

type DefaultServiceIntegration implements ServiceIntegration {
  key: String!
  name: String!
}

input DeleteApiKeyInput {
  apiKeyId: ID!
}

type DeleteApiKeyOutput {
  apiKey: ApiKey
  error: MutationError
}

input DeleteAutoresponderInput {
  autoresponderId: ID!
}

type DeleteAutoresponderOutput {
  autoresponder: Autoresponder
  error: MutationError
}

type DeleteBusinessHoursOutput {
  error: MutationError
}

input DeleteChatAppInput {
  chatAppId: ID!
}

type DeleteChatAppOutput {
  error: MutationError
}

input DeleteChatAppSecretInput {
  chatAppId: ID!
}

type DeleteChatAppSecretOutput {
  error: MutationError
}

input DeleteCompanyInput {
  companyIdentifier: CompanyIdentifierInput!
}

type DeleteCompanyOutput {
  company: Company
  error: MutationError
}

input DeleteCustomerCardConfigInput {
  """The customer card config ID to delete."""
  customerCardConfigId: ID!
}

type DeleteCustomerCardConfigOutput {
  error: MutationError
}

input DeleteCustomerGroupInput {
  customerGroupId: ID!
}

type DeleteCustomerGroupOutput {
  error: MutationError
}

input DeleteCustomerInput {
  customerId: ID!
}

type DeleteCustomerOutput {
  error: MutationError
}

input DeleteCustomerSurveyInput {
  customerSurveyId: ID!
}

type DeleteCustomerSurveyOutput {
  error: MutationError
}

input DeleteEscalationPathInput {
  escalationPathId: ID!
}

type DeleteEscalationPathOutput {
  error: MutationError
}

type DeleteGithubUserAuthIntegrationOutput {
  deletedIntegrationId: ID
  error: MutationError
}

input DeleteHelpCenterArticleGroupInput {
  helpCenterArticleGroupId: ID!
}

type DeleteHelpCenterArticleGroupOutput {
  error: MutationError
}

input DeleteHelpCenterArticleInput {
  helpCenterArticleId: ID!
}

type DeleteHelpCenterArticleOutput {
  error: MutationError
}

input DeleteHelpCenterInput {
  helpCenterId: ID!
}

type DeleteHelpCenterOutput {
  error: MutationError
}

input DeleteKnowledgeSourceInput {
  knowledgeSourceId: ID!
}

type DeleteKnowledgeSourceOutput {
  error: MutationError
}

input DeleteMachineUserInput {
  machineUserId: ID!
}

type DeleteMachineUserOutput {
  error: MutationError
  machineUser: MachineUser
}

input DeleteMyFavoritePageInput {
  favoritePageId: ID!
}

type DeleteMyFavoritePageOutput {
  error: MutationError
}

type DeleteMyLinearIntegrationOutput {
  error: MutationError
}

type DeleteMyMSTeamsIntegrationOutput {
  error: MutationError
  integration: UserMSTeamsIntegration
}

input DeleteMyServiceAuthorizationInput {
  serviceAuthorizationId: ID!
}

type DeleteMyServiceAuthorizationOutput {
  error: MutationError
}

type DeleteMySlackIntegrationOutput {
  error: MutationError
}

input DeleteNoteInput {
  noteId: ID!
}

type DeleteNoteOutput {
  error: MutationError
  note: Note
}

input DeleteSavedThreadsViewInput {
  savedThreadsViewId: ID!
}

type DeleteSavedThreadsViewOutput {
  error: MutationError
}

input DeleteServiceAuthorizationInput {
  serviceAuthorizationId: ID!
}

type DeleteServiceAuthorizationOutput {
  error: MutationError
}

input DeleteServiceLevelAgreementInput {
  serviceLevelAgreementId: ID!
}

type DeleteServiceLevelAgreementOutput {
  error: MutationError
  serviceLevelAgreement: ServiceLevelAgreement
}

input DeleteSnippetInput {
  snippetId: ID!
}

type DeleteSnippetOutput {
  error: MutationError
  snippet: Snippet
}

input DeleteTenantFieldInput {
  tenantFieldId: ID!
}

type DeleteTenantFieldOutput {
  error: MutationError
  tenantField: TenantField
}

input DeleteTenantFieldSchemaInput {
  tenantFieldSchemaId: ID!
}

type DeleteTenantFieldSchemaOutput {
  error: MutationError
  tenantFieldSchema: TenantFieldSchema
}

input DeleteTenantInput {
  tenantIdentifier: TenantIdentifierInput!
}

type DeleteTenantOutput {
  error: MutationError
  tenant: Tenant
}

input DeleteThreadChannelAssociationInput {
  threadChannelAssociationId: ID!
}

type DeleteThreadChannelAssociationOutput {
  error: MutationError
}

input DeleteThreadFieldIdentifier {
  key: String!
  threadId: ID!
}

input DeleteThreadFieldInput {
  identifier: DeleteThreadFieldIdentifier!
}

type DeleteThreadFieldOutput {
  error: MutationError
}

input DeleteThreadFieldSchemaInput {
  threadFieldSchemaId: ID!
}

type DeleteThreadFieldSchemaOutput {
  error: MutationError
}

input DeleteThreadLinkInput {
  threadLinkId: ID!
}

type DeleteThreadLinkOutput {
  error: MutationError
}

input DeleteTierInput {
  tierId: ID!
}

type DeleteTierOutput {
  error: MutationError
  tier: Tier
}

input DeleteUserAuthDiscordChannelIntegrationInput {
  integrationId: ID!
}

type DeleteUserAuthDiscordChannelIntegrationOutput {
  error: MutationError
}

input DeleteUserAuthSlackIntegrationInput {
  slackTeamId: String!
}

type DeleteUserAuthSlackIntegrationOutput {
  error: MutationError
}

input DeleteUserInput {
  userId: ID!
}

type DeleteUserOutput {
  error: MutationError
}

input DeleteWebhookTargetInput {
  webhookTargetId: ID!
}

type DeleteWebhookTargetOutput {
  error: MutationError
}

input DeleteWorkflowRuleInput {
  workflowRuleId: ID!
}

type DeleteWorkflowRuleOutput {
  error: MutationError
}

input DeleteWorkspaceDiscordChannelIntegrationInput {
  integrationId: ID!
}

type DeleteWorkspaceDiscordChannelIntegrationOutput {
  error: MutationError
}

input DeleteWorkspaceDiscordIntegrationInput {
  integrationId: ID!
}

type DeleteWorkspaceDiscordIntegrationOutput {
  error: MutationError
  integration: WorkspaceDiscordIntegration
}

type DeleteWorkspaceEmailDomainSettingsOutput {
  error: MutationError
}

input DeleteWorkspaceFileInput {
  workspaceFileId: ID!
}

type DeleteWorkspaceFileOutput {
  error: MutationError
}

input DeleteWorkspaceInviteInput {
  inviteId: ID!
}

type DeleteWorkspaceInviteOutput {
  error: MutationError
  invite: WorkspaceInvite
}

input DeleteWorkspaceMSTeamsIntegrationInput {
  integrationId: ID!
}

type DeleteWorkspaceMSTeamsIntegrationOutput {
  error: MutationError
  integration: WorkspaceMSTeamsIntegration
}

input DeleteWorkspaceSlackChannelIntegrationInput {
  integrationId: ID!
}

type DeleteWorkspaceSlackChannelIntegrationOutput {
  error: MutationError
  integration: WorkspaceSlackChannelIntegration
}

input DeleteWorkspaceSlackIntegrationInput {
  integrationId: ID!
}

type DeleteWorkspaceSlackIntegrationOutput {
  error: MutationError
  integration: WorkspaceSlackIntegration
}

type DeletedCustomerActor {
  customerId: ID!
}

type DeletedCustomerEmailActor {
  customerId: ID!
}

type DependsOnLabelType {
  labelTypeId: ID!
}

input DependsOnThreadFieldInput {
  threadFieldSchemaId: ID!
  threadFieldSchemaValue: String!
}

type DependsOnThreadFieldType {
  threadFieldSchemaId: ID!
  threadFieldSchemaValue: String!
}

type DiscordCustomerIdentity {
  discordUserId: String!
}

type DiscordMessage {
  attachments: [Attachment!]!
  createdAt: DateTime!
  createdBy: Actor!
  deletedOnDiscordAt: DateTime
  discordMessageId: ID!
  discordMessageLink: String!
  lastEditedOnDiscordAt: DateTime
  markdownContent: String
  updatedAt: DateTime!
  updatedBy: Actor!
}

type DiscordMessageEntry {
  attachments: [Attachment!]!
  customerId: ID!
  deletedOnDiscordAt: DateTime
  discordMessageId: ID!
  discordMessageLink: String!
  lastEditedOnDiscordAt: DateTime
  markdownContent: String
}

type DiscordThreadChannelDetails {
  discordChannelId: String!
  discordChannelName: String
  discordGuildId: String!
}

type DnsRecord {
  isVerified: Boolean!
  lastCheckedAt: DateTime
  name: String!
  type: String!
  value: String!
  verifiedAt: DateTime
}

enum DoneStatusDetail {
  DONE_AUTOMATICALLY_SET
  DONE_MANUALLY_SET
  IGNORED
  TIMER_EXPIRED @deprecated(reason: "Use DONE_AUTOMATICALLY_SET instead.")
}

type Email {
  additionalRecipients: [EmailParticipant!]!
  attachments: [Attachment!]!
  category: EmailCategory!
  createdAt: DateTime!
  createdBy: Actor!
  customer: Customer!
  from: EmailParticipant!
  hiddenRecipients: [EmailParticipant!]!
  id: ID!
  inReplyToEmailId: ID
  markdownContent: String
  subject: String
  textContent: String
  thread: Thread
  threadDiscussionId: ID
  to: EmailParticipant!
  updatedAt: DateTime!
  updatedBy: Actor!
}

union EmailActor = CustomerEmailActor | DeletedCustomerEmailActor | SupportEmailAddressEmailActor | UserEmailActor

"""An object modelling an email address and if it's been verified."""
type EmailAddress {
  """The email address."""
  email: String!

  """
  If the email address ownership has been verified (e.g. via sending an email with a code). If the email is not verified, Plain may not email this address.
  """
  isVerified: Boolean!

  """When the email became verified in Plain."""
  verifiedAt: DateTime
}

input EmailAddressInput {
  email: String!
  isVerified: Boolean!
}

enum EmailAuthenticity {
  FAIL
  PASS
  UNKNOWN
}

type EmailBounce {
  bouncedAt: DateTime!
  isSendRetriable: Boolean!
  recipient: EmailParticipant!
}

enum EmailCategory {
  CUSTOMER_SURVEY
  MESSAGING
  THREAD_DISCUSSION
  UNREAD_CHAT_MESSAGES
}

type EmailCustomerIdentity {
  email: String!
}

type EmailEntry {
  additionalRecipients: [EmailParticipant!]!

  """All the attachments included in this email."""
  attachments: [Attachment!]!
  authenticity: EmailAuthenticity!

  """
  If any of the recipients bounces the email, this will contain the list of bounces.
  """
  bounces: [EmailBounce!]!

  """The category of the email."""
  category: EmailCategory!
  emailId: ID!
  from: EmailParticipant!

  """The full email's markdown content, including all replies."""
  fullMarkdownContent: String

  """The full email's text content, including all replies."""
  fullTextContent: String

  """
  Boolean indicating whether there is more markdown content available that can be resolved via the `fullMarkdownContent` field.
  """
  hasMoreMarkdownContent: Boolean!

  """
  Boolean indicating whether there is more text content available that can be resolved via the `fullTextContent` field.
  """
  hasMoreTextContent: Boolean!
  hiddenRecipients: [EmailParticipant!]!

  """
  Whether this email entry is the start of a new thread in Plain. Can be used to show the full email content.
  """
  isStartOfThread: Boolean!

  """The most recent email's markdown content."""
  markdownContent: String

  """When the email was received by Plain."""
  receivedAt: DateTime

  """
  Informs whether the email was sent successfully, bounced or failed. If the email is still being sent, the status will be 'PENDING'. Only set for outbound emails.
  """
  sendStatus: EmailSendStatus

  """
  When the email was sent. Only set for outbound emails and will be null until the email is sent.
  """
  sentAt: DateTime
  subject: String

  """The most recent email's text content."""
  textContent: String
  to: EmailParticipant!
}

type EmailParticipant {
  email: String!
  emailActor: EmailActor
  name: String
}

input EmailParticipantInput {
  email: String!
  name: String
}

type EmailPreviewUrl {
  expiresAt: DateTime!
  previewUrl: String!
}

enum EmailSendStatus {
  """
  Some (or all) of the recipients bounced the email, meaning they did not recieve it. Check 'bounces' for more details on which recipients bounced.
  """
  BOUNCED

  """
  The email failed to send. This will happen if the main recipient (To) bounced the email, or if there was an unexpected error sending the email.
  """
  FAILED

  """The email is being sent."""
  PENDING

  """The email was sent successfully to all recipients."""
  SENT
}

type EmailSignature {
  createdAt: DateTime!
  createdBy: InternalActor!
  markdown: String
  text: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

"""A union of all possible entries that can appear in a timeline."""
union Entry = ChatEntry | CustomEntry | CustomerEventEntry | DiscordMessageEntry | EmailEntry | HelpCenterAiConversationMessageEntry | LinearIssueThreadLinkStateTransitionedEntry | MSTeamsMessageEntry | NoteEntry | ServiceLevelAgreementStatusTransitionedEntry | SlackMessageEntry | SlackReplyEntry | ThreadAdditionalAssigneesTransitionedEntry | ThreadAssignmentTransitionedEntry | ThreadDiscussionEntry | ThreadDiscussionResolvedEntry | ThreadEventEntry | ThreadLabelsChangedEntry | ThreadLinkUpdatedEntry | ThreadPriorityChangedEntry | ThreadStatusTransitionedEntry

input EscalateThreadInput {
  threadId: ID!
}

type EscalateThreadOutput {
  error: MutationError
  thread: Thread
}

type EscalationPath {
  createdAt: DateTime!
  createdBy: InternalActor!
  description: String
  id: ID!
  name: String!
  steps: [EscalationPathStep!]!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type EscalationPathConnection {
  edges: [EscalationPathEdge!]!
  pageInfo: PageInfo!
}

type EscalationPathEdge {
  cursor: String!
  node: EscalationPath!
}

union EscalationPathStep = EscalationPathStepLabelType | EscalationPathStepUser

input EscalationPathStepInput {
  labelTypeId: ID
  type: EscalationPathStepType!
  userId: ID
}

type EscalationPathStepLabelType {
  id: ID!
  labelType: LabelType!
}

enum EscalationPathStepType {
  LABEL_TYPE
  USER
}

type EscalationPathStepUser {
  id: ID!
  user: User!
}

union EventComponent = ComponentBadge | ComponentCopyButton | ComponentDivider | ComponentLinkButton | ComponentPlainText | ComponentRow | ComponentSpacer | ComponentText

input EventComponentInput {
  componentBadge: ComponentBadgeInput
  componentCopyButton: ComponentCopyButtonInput
  componentDivider: ComponentDividerInput
  componentLinkButton: ComponentLinkButtonInput
  componentPlainText: ComponentPlainTextInput
  componentRow: ComponentRowInput
  componentSpacer: ComponentSpacerInput
  componentText: ComponentTextInput
}

type FavoritePage {
  createdAt: DateTime!
  createdBy: InternalActor!
  id: ID!
  key: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type FavoritePageConnection {
  edges: [FavoritePageEdge!]!
  pageInfo: PageInfo!
}

type FavoritePageEdge {
  cursor: String!
  node: FavoritePage!
}

enum FeatureKey {
  AI_SUGGESTED_RESPONSES
  BILLING_ROTA_SEATS
  BUSINESS_HOURS
  CONNECTED_CUSTOMER_SLACK_CHANNELS
  CONNECTED_SUPPORT_EMAIL_ADDRESSES
  CUSTOMER_SURVEYS
  DATA_IMPORTERS
  DISCORD_INTEGRATION
  ESCALATION_PATHS
  HELP_CENTER
  INSIGHTS_LOOKBACK_DAYS
  LIVE_CHAT
  MORE_ACTIVE_ENG_ROTA_SEATS
  MS_TEAMS_INTEGRATION
  SERVICE_LEVEL_AGREEMENTS
  SLACK_DISCUSSIONS
  TEAM_REPORTING
  WORKFLOW_RULES
}

type FileSize {
  bytes: Int!
  kiloBytes: Float!
  megaBytes: Float!
}

type FirstResponseTimeServiceLevelAgreement implements ServiceLevelAgreement {
  breachActions: [BreachAction!]!
  createdAt: DateTime!
  createdBy: InternalActor!

  """
  This SLA will breach if it does not receive a first response within this many minutes.
  """
  firstResponseTimeMinutes: Int!
  id: ID!
  threadLabelTypeIdFilter: ServiceLevelAgreementThreadLabelTypeIdFilter
  threadPriorityFilter: [Int!]!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  useBusinessHoursOnly: Boolean!
}

input ForkThreadInput {
  threadId: ID!
  timelineEntryId: ID!
}

type ForkThreadOutput {
  error: MutationError
  thread: Thread
}

input GenerateHelpCenterArticleInput {
  helpCenterId: ID!
  threadId: ID!
}

type GenerateHelpCenterArticleOutput {
  error: MutationError
  helpCenterArticles: [HelpCenterArticle!]!
}

input GenerateReplyOption {
  key: String
  value: String
}

type GeneratedReply {
  createdAt: DateTime!
  createdBy: InternalActor!
  id: ID!
  markdown: String!
  text: String! @deprecated(reason: "Use markdown instead.")
  timelineEntryId: ID
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

input GeneratedReplyFeedbackInput {
  type: OptionalGeneratedReplyFeedbackInput
}

enum GeneratedReplyFeedbackType {
  NEGATIVE
  POSITIVE
  UNKNOWN
}

type GenericThreadLink implements ThreadLink {
  createdAt: DateTime!
  createdBy: InternalActor!
  description: String
  id: ID!
  sourceId: String!
  sourceStatus: ThreadLinkSourceStatus
  sourceType: String!
  status: ThreadLinkStatus!
  threadId: ID!
  title: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  url: String!
}

type GithubUserAuthIntegration {
  createdAt: DateTime!
  createdBy: InternalActor!
  githubUsername: String!
  id: ID!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type HeatmapHour {
  percentage: Float!
  threadIds: [String!]!
  total: Int!
}

type HeatmapMetric {
  days: [[HeatmapHour!]!]!
}

input HeatmapMetricOptionsInput {
  dimensionType: MetricDimensionType
  dimensionValue: String
  from: String
  subDimension: String
  to: String
}

type HelpCenter {
  access: HelpCenterAccessSettings
  agentAvatarImage: HelpCenterThemedImage!

  """All article groups in the help center."""
  articleGroups(after: String, before: String, first: Int, last: Int): HelpCenterArticleGroupConnection!

  """All articles in the help center."""
  articles(after: String, before: String, first: Int, last: Int): HelpCenterArticleConnection!
  authMechanism: HelpCenterAuthMechanism!
  bodyCustomJs: String
  color: String
  createdAt: DateTime!
  createdBy: InternalActor!
  deletedAt: DateTime
  deletedBy: InternalActor
  description: String
  domainSettings: HelpCenterDomainSettings!
  favicon: HelpCenterThemedImage!
  headCustomJs: String
  id: ID!
  internalName: String!
  isChatEnabled: Boolean!
  isDeleted: Boolean!
  logo: HelpCenterThemedImage!
  portalSettings: HelpCenterPortalSettings!
  publicName: String!
  publishedAt: DateTime
  publishedBy: InternalActor
  socialPreviewImage: WorkspaceFile
  type: HelpCenterType!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type HelpCenterAccessSettings {
  companyIds: [String!]!
  customerIds: [String!]!
  tenantIds: [String!]!
  tierIds: [String!]!
}

input HelpCenterAccessSettingsInput {
  companyIds: [String!]
  customerIds: [String!]
  tenantIds: [String!]
  tierIds: [String!]
}

type HelpCenterAiConversationMessageEntry {
  helpCenterAiConversationId: ID!
  helpCenterId: ID!
  markdown: String!
  messageId: ID!
}

type HelpCenterArticle {
  """The group this article belongs to, if any."""
  articleGroup: HelpCenterArticleGroup
  contentHtml: String!
  createdAt: DateTime!
  createdBy: InternalActor!
  description: String
  id: ID!
  slug: String!
  status: HelpCenterArticleStatus!
  statusChangedAt: DateTime!
  statusChangedBy: InternalActor!
  title: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type HelpCenterArticleConnection {
  edges: [HelpCenterArticleEdge!]!
  pageInfo: PageInfo!
}

type HelpCenterArticleEdge {
  cursor: String!
  node: HelpCenterArticle!
}

type HelpCenterArticleGroup {
  """Direct articles in this group."""
  articles(after: String, before: String, first: Int, last: Int): HelpCenterArticleConnection!

  """Direct child groups under this group."""
  childArticleGroups(after: String, before: String, first: Int, last: Int): HelpCenterArticleGroupConnection!
  createdAt: DateTime!
  createdBy: InternalActor!
  id: ID!
  name: String!

  """Parent group in the hierarchy. Null for top-level groups."""
  parentArticleGroup: HelpCenterArticleGroup
  slug: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type HelpCenterArticleGroupConnection {
  edges: [HelpCenterArticleGroupEdge!]!
  pageInfo: PageInfo!
}

type HelpCenterArticleGroupEdge {
  cursor: String!
  node: HelpCenterArticleGroup!
}

type HelpCenterArticleSearchResult {
  content: String!
  helpCenter: HelpCenter!
  helpCenterArticle: HelpCenterArticle!
}

enum HelpCenterArticleStatus {
  DRAFT
  PUBLISHED
}

union HelpCenterAuthMechanism = HelpCenterAuthMechanismWorkosAuthkit | HelpCenterAuthMechanismWorkosConnect

input HelpCenterAuthMechanismInput {
  workosAuthkitAuthMechanism: HelpCenterWorkosAuthkitAuthMechanismInput
  workosConnectAuthMechanism: WorkosConnectAuthMechanismInput
}

enum HelpCenterAuthMechanismType {
  WORKOS_AUTHKIT
  WORKOS_CONNECT
}

type HelpCenterAuthMechanismWorkosAuthkit {
  type: HelpCenterAuthMechanismType!
}

type HelpCenterAuthMechanismWorkosConnect {
  apiHost: String!
  appClientId: String!
  appSecretMasked: String!
  type: HelpCenterAuthMechanismType!
}

type HelpCenterConnection {
  edges: [HelpCenterEdge!]!
  pageInfo: PageInfo!
}

type HelpCenterDomainNameVerificationTxtRecord {
  name: String!
  value: String!
}

type HelpCenterDomainSettings {
  customDomainName: String
  customDomainNameVerificationTxtRecord: HelpCenterDomainNameVerificationTxtRecord
  customDomainNameVerifiedAt: DateTime
  domainName: String!
}

type HelpCenterEdge {
  cursor: String!
  node: HelpCenter!
}

type HelpCenterIndex {
  createdAt: DateTime!
  createdBy: InternalActor!
  hash: String!
  helpCenterId: ID!
  navIndex: [HelpCenterIndexItem!]!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type HelpCenterIndexItem {
  id: ID!
  parentId: ID
  slug: String!
  title: String!
  type: HelpCenterIndexItemType!
}

input HelpCenterIndexItemInput {
  entityId: ID!
  parentId: ID
  type: HelpCenterIndexItemType!
}

enum HelpCenterIndexItemType {
  ARTICLE
  ARTICLE_GROUP
}

type HelpCenterPortalSettings {
  formFields: [HelpCenterPortalSettingsFormField!]!
  isAdditionalRecipientsEnabled: Boolean!
  isEnabled: Boolean!
  threadVisibility: HelpCenterPortalSettingsThreadVisibility!
}

type HelpCenterPortalSettingsDropdownFormField {
  dropdownOptions: [HelpCenterPortalSettingsDropdownOption!]!
  id: ID!
  isRequired: Boolean!
  label: String!
  placeholder: String
  type: HelpCenterPortalSettingsFormFieldType!
}

type HelpCenterPortalSettingsDropdownOption {
  dropdownOptionId: ID
  label: String!
  threadDetails: HelpCenterPortalSettingsThreadDetails
}

input HelpCenterPortalSettingsDropdownOptionInput {
  dropdownOptionId: ID
  label: String!
  threadDetails: HelpCenterPortalSettingsThreadDetailsInput
}

union HelpCenterPortalSettingsFormField = HelpCenterPortalSettingsDropdownFormField | HelpCenterPortalSettingsTextFormField

input HelpCenterPortalSettingsFormFieldInput {
  dropdownOptions: [HelpCenterPortalSettingsDropdownOptionInput!]
  id: ID
  isRequired: Boolean!
  label: String!
  placeholder: String
  threadDetails: HelpCenterPortalSettingsThreadDetailsInput
  type: HelpCenterPortalSettingsFormFieldType!
}

enum HelpCenterPortalSettingsFormFieldType {
  DROPDOWN
  TEXT_AREA
  TEXT_INPUT
}

input HelpCenterPortalSettingsInput {
  formFields: [HelpCenterPortalSettingsFormFieldInput!]
  isAdditionalRecipientsEnabled: Boolean
  isEnabled: Boolean
  threadVisibility: HelpCenterPortalSettingsThreadVisibilityInput
}

type HelpCenterPortalSettingsTextFormField {
  id: ID!
  isRequired: Boolean!
  label: String!
  placeholder: String
  threadDetails: HelpCenterPortalSettingsThreadDetails
  type: HelpCenterPortalSettingsFormFieldType!
}

type HelpCenterPortalSettingsThreadDetails {
  assignees: [ThreadAssignee!]
  labelTypes: [LabelType!]
  priority: Int
  threadFields: [HelpCenterPortalSettingsThreadFields!]
}

input HelpCenterPortalSettingsThreadDetailsInput {
  assignees: [ThreadAssigneeInput!]
  labelTypeIds: [ID!]
  priority: Int
  threadFields: [HelpCenterPortalSettingsThreadFieldsInput!]
}

type HelpCenterPortalSettingsThreadFields {
  selectedBooleanValue: Boolean
  selectedStringValue: String
  threadFieldSchema: ThreadFieldSchema!
}

input HelpCenterPortalSettingsThreadFieldsInput {
  selectedBooleanValue: Boolean
  selectedStringValue: String
  threadFieldSchemaId: ID!
}

type HelpCenterPortalSettingsThreadVisibility {
  customerCompany: Boolean!
  customerTenants: Boolean!
}

input HelpCenterPortalSettingsThreadVisibilityInput {
  customerCompany: Boolean
  customerTenants: Boolean
}

type HelpCenterThemedImage {
  dark: WorkspaceFile
  light: WorkspaceFile
}

input HelpCenterThemedImageInput {
  dark: WorkspaceFileInput!
  light: WorkspaceFileInput!
}

enum HelpCenterType {
  INTERNAL
  PRIVATE
  PUBLIC
}

input HelpCenterWorkosAuthkitAuthMechanismInput {
  ignore: Boolean
}

input ImpersonationInput {
  asCustomer: CustomerImpersonationInput!
}

type ImportThreadChannelDetails {
  importIntegrationKey: String!
  importSourceUrl: String
}

type IndexedDocument {
  createdAt: DateTime!
  createdBy: InternalActor!
  id: ID!
  labelTypes: [LabelType!]!
  status: IndexedDocumentStatus!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  url: String!
}

type IndexedDocumentConnection {
  edges: [IndexedDocumentEdge!]!
  pageInfo: PageInfo!
}

type IndexedDocumentEdge {
  cursor: String!
  node: IndexedDocument!
}

type IndexedDocumentSearchResult {
  content: String!
  indexedDocument: IndexedDocument!
}

union IndexedDocumentStatus = IndexedDocumentStatusFailed | IndexedDocumentStatusIndexed | IndexedDocumentStatusPending

type IndexedDocumentStatusFailed {
  failedAt: DateTime!
  reason: String!
}

type IndexedDocumentStatusIndexed {
  indexedAt: DateTime!
}

type IndexedDocumentStatusPending {
  startedAt: DateTime!
}

input IndexedDocumentsFilter {
  knowledgeSourceId: ID
}

union IndexingStatus = IndexingStatusFailed | IndexingStatusIndexed | IndexingStatusPending

type IndexingStatusFailed {
  failedAt: DateTime!
  reason: String!
}

type IndexingStatusIndexed {
  indexedAt: DateTime!
}

type IndexingStatusPending {
  startedAt: DateTime!
}

input IntArrayInput {
  value: [Int!]!
}

input IntInput {
  value: Int!
}

union InternalActor = MachineUserActor | SystemActor | UserActor

input InviteUserToWorkspaceInput {
  email: String!
  roleIds: [ID!] @deprecated(reason: "Use roleKey instead.")
  roleKey: RoleKey
  usingBillingRotaSeat: BooleanInput
}

type InviteUserToWorkspaceOutput {
  error: MutationError
  invite: WorkspaceInvite
}

type IssueTrackerField {
  isRequired: Boolean!
  key: String!
  name: String!
  options: [IssueTrackerFieldOption!]!
  parentFieldKey: String
  selectedValue: String
  type: IssueTrackerFieldType!
}

input IssueTrackerFieldInput {
  key: String!
  value: String!
}

type IssueTrackerFieldOption {
  color: String
  icon: String
  name: String!
  value: String!
}

enum IssueTrackerFieldType {
  SELECT
}

type JiraIntegrationToken {
  createdAt: DateTime!
  token: String!
}

type JiraIssueThreadLink implements ThreadLink {
  createdAt: DateTime!
  createdBy: InternalActor!
  description: String
  id: ID!
  jiraIssueId: ID!
  jiraIssueKey: String!
  jiraIssueType: JiraIssueType!
  sourceId: String!
  sourceType: String!
  status: ThreadLinkStatus!
  threadId: ID!
  title: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  url: String!
}

input JiraIssueThreadLinkInput {
  jiraIssueId: ID!
}

type JiraIssueType {
  iconUrl: String!
  name: String!
}

type JiraSite {
  avatarUrl: String
  id: ID!
  name: String!
  url: String!
}

type JiraSiteIntegration implements ServiceIntegration {
  key: String!
  name: String!
  site: JiraSite!
}

union KnowledgeSource = KnowledgeSourceSitemap | KnowledgeSourceUrl

type KnowledgeSourceConnection {
  edges: [KnowledgeSourceEdge!]!
  pageInfo: PageInfo!
}

type KnowledgeSourceEdge {
  cursor: String!
  node: KnowledgeSource!
}

union KnowledgeSourceSearchResult = HelpCenterArticleSearchResult | IndexedDocumentSearchResult

type KnowledgeSourceSitemap {
  createdAt: DateTime!
  createdBy: InternalActor!
  id: ID!
  labelTypes: [LabelType!]!
  status: IndexingStatus!
  type: KnowledgeSourceType!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  url: String!
}

enum KnowledgeSourceType {
  SITEMAP
  URL
}

type KnowledgeSourceUrl {
  createdAt: DateTime!
  createdBy: InternalActor!
  id: ID!
  labelTypes: [LabelType!]!
  status: IndexingStatus!
  type: KnowledgeSourceType!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  url: String!
}

input KnowledgeSourcesFilter {
  type: KnowledgeSourceType
}

type Label {
  createdAt: DateTime!
  createdBy: Actor!
  id: ID!
  labelType: LabelType!
  updatedAt: DateTime!
  updatedBy: Actor!
}

type LabelType {
  archivedAt: DateTime
  archivedBy: InternalActor
  color: String
  createdAt: DateTime!
  createdBy: InternalActor!
  description: String
  icon: String
  id: ID!
  isArchived: Boolean!
  name: String!
  parentLabelType: LabelType

  """The position of the label type. Always relative to its parent."""
  position: String!
  type: LabelTypeType!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type LabelTypeConnection {
  edges: [LabelTypeEdge!]!
  pageInfo: PageInfo!
}

type LabelTypeEdge {
  cursor: String!
  node: LabelType!
}

input LabelTypeFilter {
  isArchived: Boolean
}

enum LabelTypeType {
  DEFAULT
  TEAM
}

type LinearIntegrationToken {
  token: String!
}

type LinearIssueState {
  color: String!
  label: String!
  type: LinearIssueStateType!
}

"""
Represents the possible states of a Linear issue, sourced from the Linear API.
Reference: https://studio.apollographql.com/public/Linear-API/variant/current/schema/reference/objects/WorkflowState#type
"""
enum LinearIssueStateType {
  BACKLOG
  CANCELLED
  COMPLETED
  STARTED
  TRIAGE

  """Placeholder for unknown or unsupported future states from Linear."""
  UNKNOWN
  UNSTARTED
}

type LinearIssueThreadLink implements ThreadLink {
  createdAt: DateTime!
  createdBy: InternalActor!
  description: String
  id: ID!
  linearIssueCreatedAt: DateTime!
  linearIssueId: ID!
  linearIssueIdentifier: String!
  linearIssueState: LinearIssueState!
  linearIssueUpdatedAt: DateTime!
  linearIssueUrl: String! @deprecated(reason: "Use url instead.")
  sourceId: String!
  sourceType: String!
  status: ThreadLinkStatus!
  threadId: ID!
  title: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  url: String!
}

input LinearIssueThreadLinkInput {
  linearIssueId: ID!
  linearIssueUrl: String!
}

type LinearIssueThreadLinkStateTransitionedEntry {
  linearIssueId: ID!

  """
  Refers to the id of the WorkflowState object in Linear. This can be used to fetch the WorkflowState from the Linear API.
  """
  nextLinearStateId: ID!

  """
  Refers to the id of the WorkflowState object in Linear. This can be used to fetch the WorkflowState from the Linear API.
  """
  previousLinearStateId: ID!
}

type MSTeamsChannelMember {
  displayName: String!
  email: String!
  id: ID!
  roles: [MSTeamsChannelMemberRole!]!
  tenantId: ID!
  userId: ID!
  visibleHistoryStartDateTime: String!
}

enum MSTeamsChannelMemberRole {
  guest
  owner
}

type MSTeamsChannelMembers {
  members: [MSTeamsChannelMember!]!
}

type MSTeamsMessage {
  attachments: [Attachment!]!
  createdAt: DateTime!
  createdBy: Actor!
  deletedOnMsTeamsAt: DateTime
  hasUnprocessedAttachments: Boolean!
  id: ID!
  lastEditedOnMsTeamsAt: DateTime
  markdownContent: String
  msTeamsConversationId: ID
  msTeamsMessageId: ID
  msTeamsMessageLink: String!
  msTeamsTeamId: ID
  msTeamsTenantId: ID
  parentMessageId: ID
  text: String!
  threadId: ID
  updatedAt: DateTime!
  updatedBy: Actor!
}

type MSTeamsMessageEntry {
  attachments: [Attachment!]!
  customerId: ID!
  deletedOnMsTeamsAt: DateTime
  hasUnprocessedAttachments: Boolean!
  lastEditedOnMsTeamsAt: DateTime
  markdownContent: String
  msTeamsMessageId: ID!
  msTeamsMessageLink: String!
  text: String!
}

type MSTeamsThreadChannelDetails {
  msTeamsChannelId: ID!
  msTeamsChannelName: String!
  msTeamsTeamId: ID!
  msTeamsTeamName: String!
}

input MSTeamsThreadChannelDetailsInput {
  msTeamsChannelId: ID!
  msTeamsTeamId: ID!
}

type MachineUser {
  apiKey(apiKeyId: ID!): ApiKey
  apiKeys(after: String, before: String, first: Int, last: Int): ApiKeyConnection!
  avatar: WorkspaceFile
  createdAt: DateTime!
  createdBy: InternalActor!
  deletedAt: DateTime
  deletedBy: Actor
  description: String
  fullName: String!
  id: ID!
  isDeleted: Boolean!
  publicName: String!

  """
  The type of machine user. Defaults to API_USER if not specified during creation.
  """
  type: MachineUserType!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type MachineUserActor {
  machineUser: MachineUser!
  machineUserId: ID!
}

type MachineUserConnection {
  edges: [MachineUserEdge!]!
  pageInfo: PageInfo!
}

type MachineUserEdge {
  cursor: String!
  node: MachineUser!
}

enum MachineUserType {
  """A machine user that represents an AI Agent"""
  AI_AGENT

  """A machine user that interacts via API"""
  API_USER
}

input MachineUsersFilter {
  type: MachineUserType
}

input MarkCustomerAsSpamInput {
  customerId: ID!
}

type MarkCustomerAsSpamOutput {
  customer: Customer
  error: MutationError
}

input MarkThreadAsDoneInput {
  statusDetail: DoneStatusDetail
  threadId: ID!
}

type MarkThreadAsDoneOutput {
  error: MutationError
  thread: Thread
}

input MarkThreadAsTodoInput {
  statusDetail: TodoStatusDetail
  threadId: ID!
}

type MarkThreadAsTodoOutput {
  error: MutationError
  thread: Thread
}

input MarkThreadDiscussionAsResolvedInput {
  threadDiscussionId: ID!
}

type MarkThreadDiscussionAsResolvedOutput {
  error: MutationError
}

input MentionInput {
  displayName: String!
  userId: ID!
}

enum MessageSource {
  API
  CHAT
  DISCORD
  EMAIL
  MS_TEAMS
  SLACK
}

type MeteredFeatureEntitlement implements BillingFeatureEntitlement {
  current: Int!
  feature: FeatureKey!
  isEntitled: Boolean!
  limit: Int!
}

type MetricDimension {
  type: MetricDimensionType!
  value: String!
}

enum MetricDimensionType {
  COMPANY
  CUSTOMER_GROUP
  LABEL_TYPE
  MESSAGE_SOURCE
  PRIORITY
  TENANT_FIELD
  THREAD_FIELD
  TIER
}

type MinimalThreadWithDistance {
  customerId: ID!
  distance: Float!
  threadId: ID!
  tierId: ID
}

input MoveLabelTypeInput {
  """
  Move the label type immediately after the label type with the given ID. Required if beforeLabelTypeId is not provided.
  """
  afterLabelTypeId: ID

  """
  Move the label type immediately before the label type with the given ID. Required if afterLabelTypeId is not provided.
  """
  beforeLabelTypeId: ID
  labelTypeId: ID!

  """
  Move the label type to be a child of the specified parent. When provided alone, the label will be moved to the end of the parent's children. When provided with afterLabelTypeId or beforeLabelTypeId, validates that the reference label has the same parent.
  """
  parentLabelTypeId: ID
}

type MoveLabelTypeOutput {
  error: MutationError
  labelType: LabelType
}

type Mutation {
  acceptWorkspaceInvite(input: AcceptWorkspaceInviteInput!): AcceptWorkspaceInviteOutput!
  addAdditionalAssignees(input: AddAdditionalAssigneesInput!): AddAdditionalAssigneesOutput!

  """Add a customer to a customer group."""
  addCustomerToCustomerGroups(input: AddCustomerToCustomerGroupsInput!): AddCustomerToCustomerGroupsOutput!
  addCustomerToTenants(input: AddCustomerToTenantsInput!): AddCustomerToTenantsOutput!
  addGeneratedReply(input: AddGeneratedReplyInput!): AddGeneratedReplyOutput!
  addLabels(input: AddLabelsInput!): AddLabelsOutput!
  addLabelsToUser(input: AddLabelsToUserInput!): AddLabelsToUserOutput!
  addMembersToTier(input: AddMembersToTierInput!): AddMembersToTierOutput!
  addUserToActiveBillingRota(input: AddUserToActiveBillingRotaInput!): AddUserToActiveBillingRotaOutput!
  addWorkspaceAlternateSupportEmailAddress(input: AddWorkspaceAlternateSupportEmailAddressInput!): AddWorkspaceAlternateSupportEmailAddressOutput!
  archiveLabelType(input: ArchiveLabelTypeInput!): ArchiveLabelTypeOutput!
  assignRolesToUser(input: AssignRolesToUserInput!): AssignRolesToUserOutput!
  assignThread(input: AssignThreadInput!): AssignThreadOutput!
  bulkJoinSlackChannels(input: BulkJoinSlackChannelsInput!): BulkJoinSlackChannelsOutput!
  bulkUpsertThreadFields(input: BulkUpsertThreadFieldsInput!): BulkUpsertThreadFieldsOutput!
  calculateRoleChangeCost(input: CalculateRoleChangeCostInput!): CalculateRoleChangeCostOutput!
  changeBillingPlan(input: ChangeBillingPlanInput!): ChangeBillingPlanOutput!
  changeThreadCustomer(input: ChangeThreadCustomerInput!): ChangeThreadCustomerOutput!
  changeThreadPriority(input: ChangeThreadPriorityInput!): ChangeThreadPriorityOutput!
  changeUserStatus(input: ChangeUserStatusInput!): ChangeUserStatusOutput!
  completeServiceAuthorization(input: CompleteServiceAuthorizationInput!): CompleteServiceAuthorizationOutput!
  createApiKey(input: CreateApiKeyInput!): CreateApiKeyOutput!
  createAttachmentDownloadUrl(input: CreateAttachmentDownloadUrlInput!): CreateAttachmentDownloadUrlOutput!
  createAttachmentUploadUrl(input: CreateAttachmentUploadUrlInput!): CreateAttachmentUploadUrlOutput!
  createAutoresponder(input: CreateAutoresponderInput!): CreateAutoresponderOutput!
  createBillingPortalSession: CreateBillingPortalSessionOutput!
  createChatApp(input: CreateChatAppInput!): CreateChatAppOutput!
  createChatAppSecret(input: CreateChatAppSecretInput!): CreateChatAppSecretOutput!
  createCheckoutSession(input: CreateCheckoutSessionInput!): CreateCheckoutSessionOutput!

  """
  Creates a customer card config. A maximum of 25 card configs can be created.
  """
  createCustomerCardConfig(input: CreateCustomerCardConfigInput!): CreateCustomerCardConfigOutput!

  """Create a new customer event."""
  createCustomerEvent(input: CreateCustomerEventInput!): CreateCustomerEventOutput!

  """Create a new customer group."""
  createCustomerGroup(input: CreateCustomerGroupInput!): CreateCustomerGroupOutput!
  createCustomerSurvey(input: CreateCustomerSurveyInput!): CreateCustomerSurveyOutput!
  createEmailPreviewUrl(input: CreateEmailPreviewUrlInput!): CreateEmailPreviewUrlOutput!
  createEscalationPath(input: CreateEscalationPathInput!): CreateEscalationPathOutput!
  createGithubUserAuthIntegration(input: CreateGithubUserAuthIntegrationInput!): CreateGithubUserAuthIntegrationOutput!
  createHelpCenter(input: CreateHelpCenterInput!): CreateHelpCenterOutput!
  createHelpCenterArticleGroup(input: CreateHelpCenterArticleGroupInput!): CreateHelpCenterArticleGroupOutput!
  createIndexedDocument(input: CreateIndexedDocumentInput!): CreateIndexedDocumentOutput!
  createIssueTrackerIssue(input: CreateIssueTrackerIssueInput!): CreateIssueTrackerIssueOutput!
  createKnowledgeSource(input: CreateKnowledgeSourceInput!): CreateKnowledgeSourceOutput!
  createLabelType(input: CreateLabelTypeInput!): CreateLabelTypeOutput!
  createMachineUser(input: CreateMachineUserInput!): CreateMachineUserOutput!
  createMyFavoritePage(input: CreateMyFavoritePageInput!): CreateMyFavoritePageOutput!
  createMyLinearIntegration(input: CreateMyLinearIntegrationInput!): CreateMyLinearIntegrationOutput!
  createMyMSTeamsIntegration(input: CreateMyMSTeamsIntegrationInput!): CreateMyMSTeamsIntegrationOutput!
  createMySlackIntegration(input: CreateMySlackIntegrationInput!): CreateMySlackIntegrationOutput!
  createNote(input: CreateNoteInput!): CreateNoteOutput!
  createSavedThreadsView(input: CreateSavedThreadsViewInput!): CreateSavedThreadsViewOutput!
  createServiceLevelAgreement(input: CreateServiceLevelAgreementInput!): CreateServiceLevelAgreementOutput!
  createSnippet(input: CreateSnippetInput!): CreateSnippetOutput!
  createThread(input: CreateThreadInput!): CreateThreadOutput!
  createThreadChannelAssociation(input: CreateThreadChannelAssociationInput!): CreateThreadChannelAssociationOutput!
  createThreadDiscussion(input: CreateThreadDiscussionInput!): CreateThreadDiscussionOutput!

  """Create a new thread event."""
  createThreadEvent(input: CreateThreadEventInput!): CreateThreadEventOutput!
  createThreadFieldSchema(input: CreateThreadFieldSchemaInput!): CreateThreadFieldSchemaOutput!
  createThreadLink(input: CreateThreadLinkInput!): CreateThreadLinkOutput!
  createTier(input: CreateTierInput!): CreateTierOutput!
  createUserAccount(input: CreateUserAccountInput!): CreateUserAccountOutput!
  createUserAuthDiscordChannelIntegration(input: CreateUserAuthDiscordChannelIntegrationInput!): CreateUserAuthDiscordChannelIntegrationOutput!
  createUserAuthSlackIntegration(input: CreateUserAuthSlackIntegrationInput!): CreateUserAuthSlackIntegrationOutput!

  """Creates a webhook target."""
  createWebhookTarget(input: CreateWebhookTargetInput!): CreateWebhookTargetOutput!
  createWorkflowRule(input: CreateWorkflowRuleInput!): CreateWorkflowRuleOutput!
  createWorkspace(input: CreateWorkspaceInput!): CreateWorkspaceOutput!
  createWorkspaceDiscordChannelIntegration(input: CreateWorkspaceDiscordChannelIntegrationInput!): CreateWorkspaceDiscordChannelIntegrationOutput!
  createWorkspaceDiscordIntegration(input: CreateWorkspaceDiscordIntegrationInput!): CreateWorkspaceDiscordIntegrationOutput!
  createWorkspaceEmailDomainSettings(input: CreateWorkspaceEmailDomainSettingsInput!): CreateWorkspaceEmailDomainSettingsOutput!
  createWorkspaceFileUploadUrl(input: CreateWorkspaceFileUploadUrlInput!): CreateWorkspaceFileUploadUrlOutput!
  createWorkspaceMSTeamsIntegration(input: CreateWorkspaceMSTeamsIntegrationInput!): CreateWorkspaceMSTeamsIntegrationOutput!
  createWorkspaceSlackChannelIntegration(input: CreateWorkspaceSlackChannelIntegrationInput!): CreateWorkspaceSlackChannelIntegrationOutput!
  createWorkspaceSlackIntegration(input: CreateWorkspaceSlackIntegrationInput!): CreateWorkspaceSlackIntegrationOutput!
  deleteApiKey(input: DeleteApiKeyInput!): DeleteApiKeyOutput!
  deleteAutoresponder(input: DeleteAutoresponderInput!): DeleteAutoresponderOutput!
  deleteBusinessHours: DeleteBusinessHoursOutput! @deprecated(reason: "Use syncBusinessHoursSlots instead.")
  deleteChatApp(input: DeleteChatAppInput!): DeleteChatAppOutput!
  deleteChatAppSecret(input: DeleteChatAppSecretInput!): DeleteChatAppSecretOutput!
  deleteCompany(input: DeleteCompanyInput!): DeleteCompanyOutput!

  """
  Deletes a customer and all of their data stored on Plain. This action cannot be reversed.
  """
  deleteCustomer(input: DeleteCustomerInput!): DeleteCustomerOutput!

  """Deletes a customer card config."""
  deleteCustomerCardConfig(input: DeleteCustomerCardConfigInput!): DeleteCustomerCardConfigOutput!

  """Delete a customer group by ID."""
  deleteCustomerGroup(input: DeleteCustomerGroupInput!): DeleteCustomerGroupOutput!
  deleteCustomerSurvey(input: DeleteCustomerSurveyInput!): DeleteCustomerSurveyOutput!
  deleteEscalationPath(input: DeleteEscalationPathInput!): DeleteEscalationPathOutput!
  deleteGithubUserAuthIntegration: DeleteGithubUserAuthIntegrationOutput!
  deleteHelpCenter(input: DeleteHelpCenterInput!): DeleteHelpCenterOutput!
  deleteHelpCenterArticle(input: DeleteHelpCenterArticleInput!): DeleteHelpCenterArticleOutput!
  deleteHelpCenterArticleGroup(input: DeleteHelpCenterArticleGroupInput!): DeleteHelpCenterArticleGroupOutput!
  deleteKnowledgeSource(input: DeleteKnowledgeSourceInput!): DeleteKnowledgeSourceOutput!
  deleteMachineUser(input: DeleteMachineUserInput!): DeleteMachineUserOutput!
  deleteMyFavoritePage(input: DeleteMyFavoritePageInput!): DeleteMyFavoritePageOutput!
  deleteMyLinearIntegration: DeleteMyLinearIntegrationOutput!
  deleteMyMSTeamsIntegration: DeleteMyMSTeamsIntegrationOutput!

  """Delete personal service authorizations for the current user."""
  deleteMyServiceAuthorization(input: DeleteMyServiceAuthorizationInput!): DeleteMyServiceAuthorizationOutput!
  deleteMySlackIntegration: DeleteMySlackIntegrationOutput!
  deleteNote(input: DeleteNoteInput!): DeleteNoteOutput!
  deleteSavedThreadsView(input: DeleteSavedThreadsViewInput!): DeleteSavedThreadsViewOutput!

  """Delete the workspace service authorization."""
  deleteServiceAuthorization(input: DeleteServiceAuthorizationInput!): DeleteServiceAuthorizationOutput!
  deleteServiceLevelAgreement(input: DeleteServiceLevelAgreementInput!): DeleteServiceLevelAgreementOutput!
  deleteSnippet(input: DeleteSnippetInput!): DeleteSnippetOutput!
  deleteTenant(input: DeleteTenantInput!): DeleteTenantOutput!
  deleteTenantField(input: DeleteTenantFieldInput!): DeleteTenantFieldOutput!
  deleteTenantFieldSchema(input: DeleteTenantFieldSchemaInput!): DeleteTenantFieldSchemaOutput!
  deleteThreadChannelAssociation(input: DeleteThreadChannelAssociationInput!): DeleteThreadChannelAssociationOutput!
  deleteThreadField(input: DeleteThreadFieldInput!): DeleteThreadFieldOutput!
  deleteThreadFieldSchema(input: DeleteThreadFieldSchemaInput!): DeleteThreadFieldSchemaOutput!
  deleteThreadLink(input: DeleteThreadLinkInput!): DeleteThreadLinkOutput!
  deleteTier(input: DeleteTierInput!): DeleteTierOutput!
  deleteUser(input: DeleteUserInput!): DeleteUserOutput!
  deleteUserAuthDiscordChannelIntegration(input: DeleteUserAuthDiscordChannelIntegrationInput!): DeleteUserAuthDiscordChannelIntegrationOutput!
  deleteUserAuthSlackIntegration(input: DeleteUserAuthSlackIntegrationInput!): DeleteUserAuthSlackIntegrationOutput!

  """Deletes a webhook target."""
  deleteWebhookTarget(input: DeleteWebhookTargetInput!): DeleteWebhookTargetOutput!
  deleteWorkflowRule(input: DeleteWorkflowRuleInput!): DeleteWorkflowRuleOutput!
  deleteWorkspaceDiscordChannelIntegration(input: DeleteWorkspaceDiscordChannelIntegrationInput!): DeleteWorkspaceDiscordChannelIntegrationOutput!
  deleteWorkspaceDiscordIntegration(input: DeleteWorkspaceDiscordIntegrationInput!): DeleteWorkspaceDiscordIntegrationOutput!
  deleteWorkspaceEmailDomainSettings: DeleteWorkspaceEmailDomainSettingsOutput!
  deleteWorkspaceFile(input: DeleteWorkspaceFileInput!): DeleteWorkspaceFileOutput!
  deleteWorkspaceInvite(input: DeleteWorkspaceInviteInput!): DeleteWorkspaceInviteOutput!
  deleteWorkspaceMSTeamsIntegration(input: DeleteWorkspaceMSTeamsIntegrationInput!): DeleteWorkspaceMSTeamsIntegrationOutput!
  deleteWorkspaceSlackChannelIntegration(input: DeleteWorkspaceSlackChannelIntegrationInput!): DeleteWorkspaceSlackChannelIntegrationOutput!
  deleteWorkspaceSlackIntegration(input: DeleteWorkspaceSlackIntegrationInput!): DeleteWorkspaceSlackIntegrationOutput!
  escalateThread(input: EscalateThreadInput!): EscalateThreadOutput!
  forkThread(input: ForkThreadInput!): ForkThreadOutput!
  generateHelpCenterArticle(input: GenerateHelpCenterArticleInput!): GenerateHelpCenterArticleOutput!
  inviteUserToWorkspace(input: InviteUserToWorkspaceInput!): InviteUserToWorkspaceOutput!

  """Marks a customer as spam."""
  markCustomerAsSpam(input: MarkCustomerAsSpamInput!): MarkCustomerAsSpamOutput!
  markThreadAsDone(input: MarkThreadAsDoneInput!): MarkThreadAsDoneOutput!
  markThreadAsTodo(input: MarkThreadAsTodoInput!): MarkThreadAsTodoOutput!
  markThreadDiscussionAsResolved(input: MarkThreadDiscussionAsResolvedInput!): MarkThreadDiscussionAsResolvedOutput!
  moveLabelType(input: MoveLabelTypeInput!): MoveLabelTypeOutput!
  previewBillingPlanChange(input: PreviewBillingPlanChangeInput!): PreviewBillingPlanChangeOutput!
  refreshConnectedDiscordChannels(input: RefreshConnectedDiscordChannelsInput!): RefreshConnectedDiscordChannelsOutput!
  refreshWorkspaceSlackChannelIntegration(input: RefreshWorkspaceSlackChannelIntegrationInput!): RefreshWorkspaceSlackChannelIntegrationOutput!
  regenerateWorkspaceHmac: RegenerateWorkspaceHmacOutput!

  """
  Reloads a customer card for a customer.
  
  Will discard whatever is in the cache and reload it from the configured API URL.
  """
  reloadCustomerCardInstance(input: ReloadCustomerCardInstanceInput!): ReloadCustomerCardInstanceOutput!
  removeAdditionalAssignees(input: RemoveAdditionalAssigneesInput!): RemoveAdditionalAssigneesOutput!

  """Remove a customer from a customer group."""
  removeCustomerFromCustomerGroups(input: RemoveCustomerFromCustomerGroupsInput!): RemoveCustomerFromCustomerGroupsOutput!
  removeCustomerFromTenants(input: RemoveCustomerFromTenantsInput!): RemoveCustomerFromTenantsOutput!
  removeLabels(input: RemoveLabelsInput!): RemoveLabelsOutput!
  removeLabelsFromUser(input: RemoveLabelsFromUserInput!): RemoveLabelsFromUserOutput!
  removeMembersFromTier(input: RemoveMembersFromTierInput!): RemoveMembersFromTierOutput!
  removeTenantFieldSchemaMapping(input: RemoveTenantFieldSchemaMappingInput!): RemoveTenantFieldSchemaMappingOutput!
  removeUserFromActiveBillingRota(input: RemoveUserFromActiveBillingRotaInput!): RemoveUserFromActiveBillingRotaOutput!
  removeWorkspaceAlternateSupportEmailAddress(input: RemoveWorkspaceAlternateSupportEmailAddressInput!): RemoveWorkspaceAlternateSupportEmailAddressOutput!
  reorderAutoresponders(input: ReorderAutorespondersInput!): ReorderAutorespondersOutput!

  """
  Reorders customer card configs.
  
  The input can be a partial input and in that case not all configs will be reordered.
  For example this allows two configs to be swapped with each other.
  
  Note: Duplicate orders are allowed by the API.
  """
  reorderCustomerCardConfigs(input: ReorderCustomerCardConfigsInput!): ReorderCustomerCardConfigsOutput!
  reorderCustomerSurveys(input: ReorderCustomerSurveysInput!): ReorderCustomerSurveysOutput!
  reorderThreadFieldSchemas(input: ReorderThreadFieldSchemasInput!): ReorderThreadFieldSchemasOutput!
  replyToEmail(input: ReplyToEmailInput!): ReplyToEmailOutput!

  """
  Reply to the last message in a thread. This mutation supports replying to threads where the last message is
  a Slack message, an email or a form submission. If the thread is empty, it will send an email to the customer.
  """
  replyToThread(input: ReplyToThreadInput!): ReplyToThreadOutput!
  resolveCustomerForMSTeamsChannel(input: ResolveCustomerForMSTeamsChannelInput!): ResolveCustomerForMSTeamsChannelOutput!

  """
  Resolves a customer for a Slack channel by finding or creating a customer associated with one of the Slack users in the channel.
  """
  resolveCustomerForSlackChannel(input: ResolveCustomerForSlackChannelInput!): ResolveCustomerForSlackChannelOutput!
  sendBulkEmail(input: SendBulkEmailInput!): SendBulkEmailOutput!
  sendChat(input: SendChatInput!): SendChatOutput!
  sendCustomerChat(input: SendCustomerChatInput!): SendCustomerChatOutput!
  sendDiscordMessage(input: SendDiscordMessageInput!): SendDiscordMessageOutput!
  sendMSTeamsMessage(input: SendMSTeamsMessageInput!): SendMSTeamsMessageOutput!
  sendNewEmail(input: SendNewEmailInput!): SendNewEmailOutput!
  sendSlackMessage(input: SendSlackMessageInput!): SendSlackMessageOutput!
  sendThreadDiscussionMessage(input: SendThreadDiscussionMessageInput!): SendThreadDiscussionMessageOutput!
  setCustomerTenants(input: SetCustomerTenantsInput!): SetCustomerTenantsOutput!
  setupTenantFieldSchemaMapping(input: SetupTenantFieldSchemaMappingInput!): SetupTenantFieldSchemaMappingOutput!
  shareThreadToUserInSlack(input: ShareThreadToUserInSlackInput!): ShareThreadToUserInSlackOutput!
  snoozeThread(input: SnoozeThreadInput!): SnoozeThreadOutput!
  startServiceAuthorization(input: StartServiceAuthorizationInput!): StartServiceAuthorizationOutput!
  syncBusinessHoursSlots(input: SyncBusinessHoursSlotsInput!): SyncBusinessHoursSlotsOutput!

  """Adds or removes a reaction from a slack message timeline entry."""
  toggleSlackMessageReaction(input: ToggleSlackMessageReactionInput!): ToggleSlackMessageReactionOutput!
  toggleWorkflowRulePublished(input: ToggleWorkflowRulePublishedInput!): ToggleWorkflowRulePublishedOutput!
  unarchiveLabelType(input: UnarchiveLabelTypeInput!): UnarchiveLabelTypeOutput!
  unassignThread(input: UnassignThreadInput!): UnassignThreadOutput!

  """Removes the spam mark from a customer."""
  unmarkCustomerAsSpam(input: UnmarkCustomerAsSpamInput!): UnmarkCustomerAsSpamOutput!
  updateActiveBillingRota(input: UpdateActiveBillingRotaInput!): UpdateActiveBillingRotaOutput!
  updateApiKey(input: UpdateApiKeyInput!): UpdateApiKeyOutput!
  updateAutoresponder(input: UpdateAutoresponderInput!): UpdateAutoresponderOutput!
  updateChatApp(input: UpdateChatAppInput!): UpdateChatAppOutput!
  updateCompanyTier(input: UpdateCompanyTierInput!): UpdateCompanyTierOutput!
  updateConnectedDiscordChannel(input: UpdateConnectedDiscordChannelInput!): UpdateConnectedDiscordChannelOutput!
  updateConnectedSlackChannel(input: UpdateConnectedSlackChannelInput!): UpdateConnectedSlackChannelOutput!

  """Partially updates a customer card config."""
  updateCustomerCardConfig(input: UpdateCustomerCardConfigInput!): UpdateCustomerCardConfigOutput!

  """Changes the company of a customer."""
  updateCustomerCompany(input: UpdateCustomerCompanyInput!): UpdateCustomerCompanyOutput!

  """Update a customer group."""
  updateCustomerGroup(input: UpdateCustomerGroupInput!): UpdateCustomerGroupOutput!
  updateCustomerSurvey(input: UpdateCustomerSurveyInput!): UpdateCustomerSurveyOutput!
  updateEscalationPath(input: UpdateEscalationPathInput!): UpdateEscalationPathOutput!
  updateGeneratedReply(input: UpdateGeneratedReplyInput!): UpdateGeneratedReplyOutput!
  updateHelpCenter(input: UpdateHelpCenterInput!): UpdateHelpCenterOutput!
  updateHelpCenterArticleGroup(input: UpdateHelpCenterArticleGroupInput!): UpdateHelpCenterArticleGroupOutput!
  updateHelpCenterCustomDomainName(input: UpdateHelpCenterCustomDomainNameInput!): UpdateHelpCenterCustomDomainNameOutput!
  updateHelpCenterIndex(input: UpdateHelpCenterIndexInput!): UpdateHelpCenterIndexOutput!
  updateLabelType(input: UpdateLabelTypeInput!): UpdateLabelTypeOutput!
  updateMachineUser(input: UpdateMachineUserInput!): UpdateMachineUserOutput!
  updateMyUser(input: UpdateMyUserInput!): UpdateMyUserOutput!
  updateSavedThreadsView(input: UpdateSavedThreadsViewInput!): UpdateSavedThreadsViewOutput!
  updateServiceLevelAgreement(input: UpdateServiceLevelAgreementInput!): UpdateServiceLevelAgreementOutput!

  """Updates a setting."""
  updateSetting(input: UpdateSettingInput!): UpdateSettingOutput!
  updateSnippet(input: UpdateSnippetInput!): UpdateSnippetOutput!
  updateTenantTier(input: UpdateTenantTierInput!): UpdateTenantTierOutput!
  updateThreadEscalationPath(input: UpdateThreadEscalationPathInput!): UpdateThreadEscalationPathOutput!
  updateThreadFieldSchema(input: UpdateThreadFieldSchemaInput!): UpdateThreadFieldSchemaOutput!
  updateThreadTenant(input: UpdateThreadTenantInput!): UpdateThreadTenantOutput!
  updateThreadTier(input: UpdateThreadTierInput!): UpdateThreadTierOutput!
  updateThreadTitle(input: UpdateThreadTitleInput!): UpdateThreadTitleOutput!
  updateTier(input: UpdateTierInput!): UpdateTierOutput!

  """Updates a webhook target."""
  updateWebhookTarget(input: UpdateWebhookTargetInput!): UpdateWebhookTargetOutput!
  updateWorkflowRule(input: UpdateWorkflowRuleInput!): UpdateWorkflowRuleOutput!
  updateWorkspace(input: UpdateWorkspaceInput!): UpdateWorkspaceOutput!
  updateWorkspaceEmailSettings(input: UpdateWorkspaceEmailSettingsInput!): UpdateWorkspaceEmailSettingsOutput!
  upsertBusinessHours(input: UpsertBusinessHoursInput!): UpsertBusinessHoursOutput! @deprecated(reason: "Use syncBusinessHoursSlots instead.")
  upsertCompany(input: UpsertCompanyInput!): UpsertCompanyOutput!

  """Creates or updates a customer."""
  upsertCustomer(input: UpsertCustomerInput!): UpsertCustomerOutput!

  """Creates or updates a customer group."""
  upsertCustomerGroup(input: UpsertCustomerGroupInput!): UpsertCustomerGroupOutput!
  upsertHelpCenterArticle(input: UpsertHelpCenterArticleInput!): UpsertHelpCenterArticleOutput!
  upsertMyEmailSignature(input: UpsertMyEmailSignatureInput!): UpsertMyEmailSignatureOutput!
  upsertTenant(input: UpsertTenantInput!): UpsertTenantOutput!
  upsertTenantField(input: UpsertTenantFieldInput!): UpsertTenantFieldOutput!
  upsertTenantFieldSchema(input: UpsertTenantFieldSchemaInput!): UpsertTenantFieldSchemaOutput!
  upsertThreadField(input: UpsertThreadFieldInput!): UpsertThreadFieldOutput!
  verifyHelpCenterCustomDomainName(input: VerifyHelpCenterCustomDomainNameInput!): VerifyHelpCenterCustomDomainNameOutput!
  verifyWorkspaceEmailDnsSettings: VerifyWorkspaceEmailDnsSettingsOutput!
  verifyWorkspaceEmailForwardingSettings(input: VerifyWorkspaceEmailForwardingSettingsInput!): VerifyWorkspaceEmailForwardingSettingsOutput!
}

"""A type indicating an error has occurred while making a mutation."""
type MutationError {
  """
  A fixed error code that can be used to handle this error, see https://www.plain.com/docs/graphql-api/error-codes for a description of each code.
  """
  code: String!

  """The array of fields that are impacted by this error."""
  fields: [MutationFieldError!]!

  """
  An English technical description of the error. This error is usually meant to be read by a developer and not an end user.
  """
  message: String!

  """
  The type of error. Can be used to display a user friendly error message.
  """
  type: MutationErrorType!
}

"""An enum for why the mutation failed overall."""
enum MutationErrorType {
  """
  The user is not authorized to do this mutation. See `message` for details on which permissions are missing.
  """
  FORBIDDEN

  """
  An unknown internal server error occurred. Retry the mutation and if it persists, please email help@plain.com
  """
  INTERNAL

  """
  Input validation failed, see the `fields` for details on why the input was invalid.
  """
  VALIDATION
}

"""
A type indicating an error has occurred with a specific field in the input.
"""
type MutationFieldError {
  """The name of the field for which the error happened."""
  field: String!

  """
  An English technical description of the error. This error is usually meant to be read by a developer and not an end user.
  """
  message: String!

  """
  The type of the error. Can be used to display a user friendly error message.
  """
  type: MutationFieldErrorType!
}

"""An enum specific to each field, explaining why validation failed."""
enum MutationFieldErrorType {
  """The input field referenced an entity that wasn't found."""
  NOT_FOUND

  """
  The field is required to be provided. String inputs may be trimmed and checked for emptiness.
  """
  REQUIRED

  """
  The field was provided, but didn't pass the requirements of the field. See `message` for details on why.
  """
  VALIDATION
}

type NextResponseTimeServiceLevelAgreement implements ServiceLevelAgreement {
  breachActions: [BreachAction!]!
  createdAt: DateTime!
  createdBy: InternalActor!
  id: ID!

  """
  This SLA will breach if it does not receive a next response within this many minutes.
  """
  nextResponseTimeMinutes: Int!
  threadLabelTypeIdFilter: ServiceLevelAgreementThreadLabelTypeIdFilter
  threadPriorityFilter: [Int!]!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  useBusinessHoursOnly: Boolean!
}

type Note {
  attachments: [Attachment!]!
  createdAt: DateTime!
  createdBy: InternalActor!
  customer: Customer!
  deletedAt: DateTime
  deletedBy: InternalActor
  id: ID!
  isDeleted: Boolean!
  markdown: String
  text: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type NoteEntry {
  attachments: [Attachment!]!
  markdown: String
  noteId: ID!
  text: String!
}

"""A number setting"""
type NumberSetting {
  """The setting code."""
  code: String!

  """
  The value of the setting. This is named uniquely (instead of just `value`) so that the union has unique fields.
  """
  numberValue: Int!

  """The scope of the setting."""
  scope: SettingScope!
}

input OptionalBooleanInput {
  value: Boolean
}

input OptionalDependsOnThreadFieldInput {
  value: DependsOnThreadFieldInput
}

input OptionalGeneratedReplyFeedbackInput {
  value: GeneratedReplyFeedbackType
}

input OptionalStringInput {
  value: String
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type PaymentMethod {
  isAvailable: Boolean!
}

type PerSeatRecurringPrice implements RecurringPrice {
  billingIntervalCount: Int!
  billingIntervalUnit: BillingIntervalUnit!
  currency: CurrencyCode!
  perSeatAmount: Int!
}

type Permissions {
  permissions: [String!]!
}

input PlainThreadLinkInput {
  plainThreadId: ID!
}

type PlainThreadThreadLink implements ThreadLink {
  createdAt: DateTime!
  createdBy: InternalActor!
  description: String
  id: ID!
  plainThreadId: ID!
  plainThreadStatusDetailType: StatusDetailType!
  sourceId: String!
  sourceType: String!
  status: ThreadLinkStatus!
  threadId: ID!
  title: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  url: String!
}

input PreviewBillingPlanChangeInput {
  intervalUnit: BillingIntervalUnit
  planKey: BillingPlanKey!
}

type PreviewBillingPlanChangeOutput {
  error: MutationError
  preview: BillingPlanChangePreview
}

type Price {
  amount: Int!
  currency: CurrencyCode!
}

type PriceTier {
  flatAmount: Int!
  maxSeats: Int!
  perSeatAmount: Int!
}

type Query {
  """This API is in beta and may change without notice."""
  activeThreadCluster(threadId: ID!): ThreadCluster
  autoresponder(autoresponderId: ID!): Autoresponder
  autoresponders(after: String, before: String, first: Int, last: Int): AutoresponderConnection!
  billingPlans(after: String, before: String, first: Int, last: Int): BillingPlanConnection!
  businessHours: BusinessHours @deprecated(reason: "Use businessHoursSlots instead.")
  businessHoursSlots: [BusinessHoursSlot!]!

  """Get a chat app by id."""
  chatApp(chatAppId: ID!): ChatApp

  """Get a chat app secret by chat app id."""
  chatAppSecret(chatAppId: ID!): ChatAppHiddenSecret

  """List chat apps."""
  chatApps(after: String, before: String, first: Int, last: Int): ChatAppConnection!
  companies(after: String, before: String, filters: CompaniesFilter, first: Int, last: Int): CompanyConnection!
  company(companyId: ID!): Company

  """
  Gets all Discord channels for this workspace, which match the specified filters.
  """
  connectedDiscordChannels(after: String, before: String, discordGuildId: String!, first: Int, last: Int): ConnectedDiscordChannelConnection!
  connectedMSTeamsChannels(after: String, before: String, first: Int, last: Int): ConnectedMSTeamsChannelConnection!
  connectedSlackChannel(connectedSlackChannelId: ID!): ConnectedSlackChannel

  """
  Gets all slack channels for this workspace, which match the specified filters.
  """
  connectedSlackChannels(after: String, before: String, filters: ConnectedSlackChannelsFilter, first: Int, last: Int): ConnectedSlackChannelConnection!
  customer(customerId: ID!): Customer
  customerByEmail(email: String!): Customer

  """
  Get a customer by its external ID. A customer's external ID is unique within a workspace.
  """
  customerByExternalId(externalId: ID!): Customer
  customerCardConfig(customerCardConfigId: ID!): CustomerCardConfig
  customerCardConfigs: [CustomerCardConfig!]!

  """
  Loads the customer's card instances.
  
  This query will return any cards that are loaded and within their expiry time.
  For cards that are past their expiry or are errored it will request a load of the cards and
  return a `CustomerCardInstanceLoading`.
  
  A maximum of 25 card instances will be returned, due to only allowing 25 customer card configs.
  """
  customerCardInstances(customerId: ID!, threadId: ID): [CustomerCardInstance!]!

  """Get a customer group by ID."""
  customerGroup(customerGroupId: ID!): CustomerGroup

  """Get a paginated list of customer groups."""
  customerGroups(after: String, before: String, filters: CustomerGroupsFilter, first: Int, last: Int): CustomerGroupConnection!
  customerSurvey(id: ID!): CustomerSurvey
  customerSurveys(after: String, before: String, first: Int, last: Int): CustomerSurveyConnection!
  customers(after: String, before: String, filters: CustomersFilter, first: Int, last: Int, sortBy: CustomersSort): CustomerConnection!
  escalationPath(id: ID!): EscalationPath
  escalationPaths(after: String, before: String, first: Int, last: Int): EscalationPathConnection!

  """This API is in beta and may change without notice."""
  generatedReplies(options: [GenerateReplyOption!], threadId: ID!): [GeneratedReply!]
  getMSTeamsMembersForChannel(msTeamsChannelId: ID!, msTeamsTeamId: ID!): MSTeamsChannelMembers!
  githubUserAuthIntegration: GithubUserAuthIntegration
  heatmapMetric(name: String!, options: HeatmapMetricOptionsInput): HeatmapMetric
  helpCenter(id: ID!): HelpCenter
  helpCenterArticle(id: ID!): HelpCenterArticle

  """Get a help center article by its slug."""
  helpCenterArticleBySlug(helpCenterId: ID!, slug: String!): HelpCenterArticle
  helpCenterArticleGroup(id: ID!): HelpCenterArticleGroup

  """Get a help center article group by its slug."""
  helpCenterArticleGroupBySlug(helpCenterId: ID!, slug: String!): HelpCenterArticleGroup
  helpCenterIndex(id: ID!): HelpCenterIndex
  helpCenters(after: String, before: String, first: Int, last: Int): HelpCenterConnection!
  indexedDocuments(after: String, before: String, filters: IndexedDocumentsFilter, first: Int, last: Int): IndexedDocumentConnection!
  issueTrackerFields(issueTrackerType: String!, selectedFields: [SelectedIssueTrackerField!]!): [IssueTrackerField!]!
  knowledgeSource(knowledgeSourceId: ID!): KnowledgeSource
  knowledgeSources(after: String, before: String, filters: KnowledgeSourcesFilter, first: Int, last: Int): KnowledgeSourceConnection!
  labelType(labelTypeId: ID!): LabelType
  labelTypes(after: String, before: String, filters: LabelTypeFilter, first: Int, last: Int): LabelTypeConnection!
  machineUser(machineUserId: ID!): MachineUser
  machineUsers(after: String, before: String, filters: MachineUsersFilter, first: Int, last: Int): MachineUserConnection!
  myBillingRota: BillingRota
  myBillingSubscription: BillingSubscription
  myEmailSignature: EmailSignature
  myFavoritePages(after: String, before: String, first: Int, last: Int): FavoritePageConnection!
  myJiraIntegrationToken: JiraIntegrationToken
  myLinearInstallationInfo(redirectUrl: String!): UserLinearInstallationInfo!
  myLinearIntegration: UserLinearIntegration
  myLinearIntegrationToken: LinearIntegrationToken
  myMSTeamsInstallationInfo(redirectUrl: String!): UserMSTeamsInstallationInfo!
  myMSTeamsIntegration: UserMSTeamsIntegration
  myMachineUser: MachineUser
  myPaymentMethod: PaymentMethod
  myPermissions: Permissions!
  mySlackInstallationInfo(redirectUrl: String!): UserSlackInstallationInfo!
  mySlackIntegration: UserSlackIntegration
  myUser: User
  myUserAccount: UserAccount
  myWorkspace: Workspace
  myWorkspaceInvites(after: String, before: String, first: Int, last: Int): WorkspaceInviteConnection!
  myWorkspaces(after: String, before: String, first: Int, last: Int): WorkspaceConnection!
  permissions: Permissions!
  relatedThreads(threadId: ID!): [ThreadWithDistance!]!
  roles(after: String, before: String, first: Int, last: Int): RoleConnection!
  savedThreadsView(savedThreadsViewId: ID!): SavedThreadsView
  savedThreadsViews(after: String, before: String, first: Int, last: Int): SavedThreadsViewConnection!
  searchCompanies(after: String, before: String, filters: CompaniesFilter, first: Int, last: Int, searchQuery: CompaniesSearchQuery!): CompanySearchResultConnection!

  """
  Search for customers based on the provided query. Returned customers are sorted by how recently
  they changed status (most recent first).
  """
  searchCustomers(after: String, before: String, first: Int, last: Int, searchQuery: CustomersSearchQuery!): CustomerSearchConnection!
  searchKnowledgeSources(pageSize: Int, searchQuery: String!): [KnowledgeSourceSearchResult!]!

  """
  Searches for slack users in a slack channel based on a search term.
  The search term can be part of either the slack's handle or full name.
  """
  searchSlackUsers(after: String, before: String, first: Int, last: Int, searchQuery: String!, slackChannelId: String!, slackTeamId: String!): SlackUserConnection!
  searchTenants(after: String, before: String, first: Int, last: Int, searchQuery: TenantsSearchQuery!): TenantSearchResultConnection!
  searchThreadLinkCandidates(after: String, before: String, filters: ThreadLinkCandidateFilter!, first: Int, last: Int, searchQuery: String!): ThreadLinkCandidateConnection!

  """
  Searches for slack users in a thread based on a search term.
  The search term can be part of either the slack's handle or full name.
  """
  searchThreadSlackUsers(after: String, before: String, first: Int, last: Int, searchQuery: String!, threadId: ID!): SlackUserConnection!
  searchThreads(after: String, before: String, filters: ThreadsFilter, first: Int, last: Int, searchQuery: ThreadsSearchQuery!): ThreadSearchResultConnection!
  serviceAuthorization(serviceAuthorizationId: ID!): ServiceAuthorization
  serviceAuthorizations(after: String, before: String, filters: ServiceAuthorizationsFilter, first: Int, last: Int): ServiceAuthorizationConnection!

  """Gets a single setting based on the code and the scope."""
  setting(code: String!, scope: SettingScopeInput!): Setting
  singleValueMetric(name: String!, options: SingleValueMetricOptions): SingleValueMetric

  """
  Gets a single slack user within a channel based on their slack user ID.
  """
  slackUser(slackChannelId: String!, slackTeamId: String!, slackUserId: ID!): SlackUser
  snippet(snippetId: ID!): Snippet
  snippets(after: String, before: String, first: Int, last: Int): SnippetConnection!

  """List all the events types you can subscribe to."""
  subscriptionEventTypes: [SubscriptionEventType!]!
  tenant(tenantId: ID!): Tenant
  tenantFieldSchemas(after: String, before: String, filters: TenantFieldSchemasFilter, first: Int, last: Int): TenantFieldSchemaConnection!
  tenants(after: String, before: String, first: Int, last: Int): TenantConnection!

  """Get a thread by its ID."""
  thread(threadId: ID!): Thread

  """
  Get a thread by its external ID. A thread's external ID is unique within a customer, hence why the customer ID is required.
  """
  threadByExternalId(customerId: ID!, externalId: ID!): Thread

  """Get a thread by its ref."""
  threadByRef(ref: String!): Thread

  """This API is in beta and may change without notice."""
  threadCluster(id: ID!): ThreadCluster

  """This API is in beta and may change without notice."""
  threadClusters(variant: String): [ThreadCluster!]!

  """This API is in beta and may change without notice."""
  threadClustersPaginated(after: String, before: String, filters: ThreadClustersFilter, first: Int, last: Int): ThreadClusterConnection!
  threadDiscussion(threadDiscussionId: ID!): ThreadDiscussion
  threadFieldSchema(threadFieldSchemaId: ID!): ThreadFieldSchema
  threadFieldSchemas(after: String, before: String, first: Int, last: Int): ThreadFieldSchemaConnection!
  threadLinkGroups(after: String, before: String, filters: ThreadLinkGroupFilter, first: Int, last: Int): ThreadLinkGroupConnection!

  """Gets a single slack user within a thread based on their slack user ID."""
  threadSlackUser(slackUserId: ID!, threadId: ID!): SlackUser
  threads(after: String, before: String, filters: ThreadsFilter, first: Int, last: Int, sortBy: ThreadsSort): ThreadConnection!
  tier(tierId: ID!): Tier
  tiers(after: String, before: String, first: Int, last: Int): TierConnection!
  timeSeriesMetric(name: String!, options: TimeSeriesMetricOptions): TimeSeriesMetric
  timelineEntries(after: String, before: String, customerId: ID!, first: Int, last: Int): TimelineEntryConnection!
  timelineEntry(customerId: ID!, timelineEntryId: ID!): TimelineEntry
  user(userId: ID!): User
  userAuthDiscordChannelInstallationInfo(redirectUrl: String!): UserAuthDiscordChannelInstallationInfo!
  userAuthDiscordChannelIntegration(discordGuildId: String!): UserAuthDiscordChannelIntegration
  userAuthDiscordChannelIntegrations(after: String, before: String, first: Int, last: Int): UserAuthDiscordChannelIntegrationConnection!
  userAuthSlackInstallationInfo(redirectUrl: String!, slackTeamId: String): UserAuthSlackInstallationInfo!
  userAuthSlackIntegration(slackTeamId: String!): UserAuthSlackIntegration
  userAuthSlackIntegrationByThreadId(threadId: ID!): UserAuthSlackIntegration

  """
  Returns a user by email or null if the user is not found.
  
  Deleted users are also returned, see isDeleted, deletedAt and deletedBy fields on the User type.
  """
  userByEmail(email: String!): User

  """
  Gets a list of Slack channels where the specified user is a member.
  This is a proxy to the Slack API's users.conversations endpoint.
  """
  userSlackChannelMemberships(slackTeamId: String!): [SlackChannelMembership!]!
  users(after: String, before: String, filters: UsersFilter, first: Int, last: Int): UserConnection!

  """Gets a webhook target."""
  webhookTarget(webhookTargetId: ID!): WebhookTarget

  """List webhook targets."""
  webhookTargets(after: String, before: String, first: Int, last: Int): WebhookTargetConnection!

  """List webhook versions."""
  webhookVersions(after: String, before: String, first: Int, last: Int): WebhookVersionConnection!

  """Get a workflow rule by id."""
  workflowRule(workflowRuleId: ID!): WorkflowRule

  """List workflow rules."""
  workflowRules(after: String, before: String, first: Int, last: Int): WorkflowRuleConnection!
  workspace(workspaceId: ID!): Workspace
  workspaceChatSettings: WorkspaceChatSettings!
  workspaceDiscordChannelInstallationInfo(redirectUrl: String!): WorkspaceDiscordChannelInstallationInfo!
  workspaceDiscordChannelIntegration(integrationId: ID!): WorkspaceDiscordChannelIntegration
  workspaceDiscordChannelIntegrations(after: String, before: String, first: Int, last: Int): WorkspaceDiscordChannelIntegrationConnection!
  workspaceDiscordIntegration(integrationId: ID!): WorkspaceDiscordIntegration
  workspaceDiscordIntegrations(after: String, before: String, first: Int, last: Int): WorkspaceDiscordIntegrationConnection!
  workspaceEmailSettings: WorkspaceEmailSettings!
  workspaceHmac: WorkspaceHmac
  workspaceInvites(after: String, before: String, first: Int, last: Int): WorkspaceInviteConnection!
  workspaceMSTeamsInstallationInfo(redirectUrl: String!): WorkspaceMSTeamsInstallationInfo!
  workspaceMSTeamsIntegration: WorkspaceMSTeamsIntegration
  workspaceSlackChannelInstallationInfo(redirectUrl: String!): WorkspaceSlackChannelInstallationInfo!
  workspaceSlackChannelIntegration(integrationId: ID!): WorkspaceSlackChannelIntegration
  workspaceSlackChannelIntegrations(after: String, before: String, first: Int, last: Int): WorkspaceSlackChannelIntegrationConnection!
  workspaceSlackInstallationInfo(redirectUrl: String!): WorkspaceSlackInstallationInfo!
  workspaceSlackIntegration(integrationId: ID!): WorkspaceSlackIntegration
  workspaceSlackIntegrations(after: String, before: String, first: Int, last: Int): WorkspaceSlackIntegrationConnection!
}

interface RecurringPrice {
  billingIntervalCount: Int!
  billingIntervalUnit: BillingIntervalUnit!
  currency: CurrencyCode!
}

input RefreshConnectedDiscordChannelsInput {
  discordGuildId: String!
}

type RefreshConnectedDiscordChannelsOutput {
  error: MutationError
}

input RefreshWorkspaceSlackChannelIntegrationInput {
  authCode: String!
  integrationId: ID!
  redirectUrl: String!
}

type RefreshWorkspaceSlackChannelIntegrationOutput {
  error: MutationError
  integration: WorkspaceSlackChannelIntegration
}

type RegenerateWorkspaceHmacOutput {
  error: MutationError
  workspaceHmac: WorkspaceHmac
}

input ReloadCustomerCardInstanceInput {
  customerCardConfigId: ID!
  customerId: ID!
  threadId: ID
}

type ReloadCustomerCardInstanceOutput {
  """
  The reloaded customer card instance. Currently this will always be a `CustomerCardInstanceLoading` type.
  """
  customerCardInstance: CustomerCardInstance
  error: MutationError
}

input RemoveAdditionalAssigneesInput {
  machineUserIds: [ID!]
  threadId: ID!
  userIds: [ID!]
}

type RemoveAdditionalAssigneesOutput {
  error: MutationError
  thread: Thread
}

input RemoveCustomerFromCustomerGroupsInput {
  customerGroupIdentifiers: [CustomerGroupIdentifier!]!
  customerId: ID!
}

type RemoveCustomerFromCustomerGroupsOutput {
  error: MutationError
}

input RemoveCustomerFromTenantsInput {
  customerIdentifier: CustomerIdentifierInput!
  tenantIdentifiers: [TenantIdentifierInput!]!
}

type RemoveCustomerFromTenantsOutput {
  customer: Customer
  error: MutationError
}

input RemoveLabelsFromUserInput {
  labelIds: [ID!]!
}

type RemoveLabelsFromUserOutput {
  error: MutationError
  labels: [Label!]!
  user: User
}

input RemoveLabelsInput {
  labelIds: [ID!]!
}

type RemoveLabelsOutput {
  error: MutationError
  thread: Thread
}

input RemoveMembersFromTierInput {
  memberIdentifiers: [TierMemberIdentifierInput!]!
}

type RemoveMembersFromTierOutput {
  error: MutationError
  memberships: [TierMembership!]!
}

input RemoveTenantFieldSchemaMappingInput {
  tenantFieldSchemaId: ID!
}

type RemoveTenantFieldSchemaMappingOutput {
  error: MutationError
  tenantFieldSchema: TenantFieldSchema
}

input RemoveUserFromActiveBillingRotaInput {
  userId: ID!
}

type RemoveUserFromActiveBillingRotaOutput {
  billingRota: BillingRota
  error: MutationError
}

input RemoveWorkspaceAlternateSupportEmailAddressInput {
  alternateSupportEmailAddress: String!
}

type RemoveWorkspaceAlternateSupportEmailAddressOutput {
  error: MutationError
  workspaceEmailDomainSettings: WorkspaceEmailDomainSettings
}

input ReorderAutorespondersInput {
  autorespondersOrder: [AutoresponderOrderInput!]!
}

type ReorderAutorespondersOutput {
  autoresponders: [Autoresponder!]
  error: MutationError
}

input ReorderCustomerCardConfigsInput {
  """An array of ordering updates."""
  customerCardConfigOrders: [CustomerCardConfigOrderInput!]!
}

type ReorderCustomerCardConfigsOutput {
  """The reordered customer card configs."""
  customerCardConfigs: [CustomerCardConfig!]
  error: MutationError
}

input ReorderCustomerSurveysInput {
  customerSurveyOrders: [CustomerSurveyOrderInput!]!
}

type ReorderCustomerSurveysOutput {
  customerSurveys: [CustomerSurvey!]
  error: MutationError
}

input ReorderThreadFieldSchemasInput {
  threadFieldSchemaOrders: [ThreadFieldSchemaOrderInput!]!
}

type ReorderThreadFieldSchemasOutput {
  error: MutationError
  threadFieldSchemas: [ThreadFieldSchema!]
}

input ReplyToEmailInput {
  additionalRecipients: [EmailParticipantInput!]
  attachmentIds: [ID!]
  customerId: ID @deprecated(reason: "Use inReplyToEmailId instead.")

  """
  Optional field for alternate from email address. If provided, it will be used as the from address in the email.
  It must match one of the workspace support email addresses (default or alternate).
  """
  fromAlternateSupportEmail: EmailParticipantInput
  hiddenRecipients: [EmailParticipantInput!]
  inReplyToEmailId: ID!
  markdownContent: String
  subject: String
  textContent: String!
}

type ReplyToEmailOutput {
  email: Email
  error: MutationError
}

input ReplyToThreadChannelSpecificOptionsInput {
  email: ReplyToThreadEmailChannelSpecificOptionsInput!
}

input ReplyToThreadEmailChannelSpecificOptionsInput {
  additionalRecipients: [EmailParticipantInput!]
  hiddenRecipients: [EmailParticipantInput!]
}

input ReplyToThreadInput {
  attachmentIds: [ID!]
  channelSpecificOptions: ReplyToThreadChannelSpecificOptionsInput
  impersonation: ImpersonationInput
  markdownContent: String
  textContent: String!
  threadId: ID!
}

type ReplyToThreadOutput {
  error: MutationError
}

input ResolveCustomerForMSTeamsChannelInput {
  msTeamsChannelId: ID!
  msTeamsTeamId: ID!
}

type ResolveCustomerForMSTeamsChannelOutput {
  customer: Customer
  error: MutationError
}

input ResolveCustomerForSlackChannelInput {
  slackChannelId: String!
  slackTeamId: String!
}

type ResolveCustomerForSlackChannelOutput {
  customer: Customer
  error: MutationError
}

type Role {
  assignableBillingSeats: [BillingSeatType!]! @deprecated(reason: "Don't use. Will be removed soon.")
  description: String
  id: ID!
  isAssignableToCustomer: Boolean! @deprecated(reason: "Use isAssignableToThread instead")
  isAssignableToThread: Boolean!
  key: RoleKey
  name: String!
  permissions: [String!]!
  requiresBillableSeat: Boolean! @deprecated(reason: "Don't use. Will be removed soon.")
}

type RoleChangeCost {
  addingSeatType: BillingSeatType!

  """
  The total price delta for the remainder of the current billing period (i.e. prorated).
  Could be negative (e.g. swapping member for viewer).
  """
  adjustedPrice: Price!

  """
  Total amount that will be invoiced immediately for the role change.
  If this is negative, we would credit the amount to your account.
  """
  dueNowPrice: Price!

  """
  The total price delta for the entire subscription billing period (i.e. non-prorated).
  Could be negative (e.g. swapping member for viewer).
  """
  fullPrice: Price!
  intervalCount: Int!
  intervalUnit: BillingIntervalUnit!

  """The number of seats."""
  quantity: Int!
  removingSeatType: BillingSeatType

  """Deprecated. Use fullPrice instead."""
  totalPrice: Price!
}

type RoleConnection {
  edges: [RoleEdge!]!
  pageInfo: PageInfo!
}

type RoleEdge {
  cursor: String!
  node: Role!
}

enum RoleKey {
  ADMIN
  NONE
  OWNER
  SUPPORT
  VIEWER
}

type SavedThreadsView {
  color: String!
  createdAt: DateTime!
  createdBy: InternalActor!
  icon: String!
  id: ID!
  name: String!
  threadsFilter: SavedThreadsViewFilter!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type SavedThreadsViewConnection {
  edges: [SavedThreadsViewEdge!]!
  pageInfo: PageInfo!
}

type SavedThreadsViewEdge {
  cursor: String!
  node: SavedThreadsView!
}

type SavedThreadsViewFilter {
  assignedToUser: [ID!]!
  companies: [ID!]!
  customerGroups: [ID!]!
  displayOptions: ThreadsDisplayOptions!
  groupBy: ThreadsGroupBy!
  labelTypeIds: [ID!]!
  layout: ThreadsLayout!
  messageSource: [MessageSource!]!
  participants: [ID!]!
  priorities: [Int!]!
  slaStatuses: [String!]!
  slaTypes: [String!]!
  sort: SavedThreadsViewSort!
  statusDetails: [StatusDetailType!]!
  statuses: [ThreadStatus!]!
  supportEmailAddresses: [String!]!
  tenants: [ID!]!
  threadFields: [SavedThreadsViewFilterThreadField!]!
  threadLinkGroupIds: [ID!]!
  tiers: [ID!]!
}

input SavedThreadsViewFilterInput {
  assignedToUser: [ID!]!
  companies: [ID!]!
  customerGroups: [ID!]!
  displayOptions: ThreadsDisplayOptionsInput!
  groupBy: ThreadsGroupBy!
  labelTypeIds: [ID!]!
  layout: ThreadsLayout!
  messageSource: [MessageSource!]!
  participants: [ID!]!
  priorities: [Int!]!
  slaStatuses: [String!]!
  slaTypes: [String!]!
  sort: ThreadsSort!
  statusDetails: [StatusDetailType!]!
  statuses: [ThreadStatus!]!
  supportEmailAddresses: [String!]!
  tenants: [ID!]!
  threadFields: [ThreadFieldFilter!]!
  threadLinkGroupIds: [ID!]!
  tiers: [ID!]!
}

type SavedThreadsViewFilterThreadField {
  booleanValue: Boolean
  key: String!
  stringValue: String
}

type SavedThreadsViewSort {
  direction: SortDirection
  field: ThreadsSortField
}

input SelectedIssueTrackerField {
  key: String!
  value: String!
}

input SendBulkEmailInput {
  markdownContent: String
  textContent: String!
  threadIds: [ID!]!
}

type SendBulkEmailOutput {
  error: MutationError
}

input SendChatInput {
  attachmentIds: [ID!]
  customerId: ID!
  text: String
  threadId: ID

  """
  When provided, this will override the timestamp of the chat. Useful when backfilling messages. Must be in ISO 8601 format (e.g. 2024-10-28T18:30:00Z).
  """
  timestamp: String
}

type SendChatOutput {
  chat: Chat
  error: MutationError
}

input SendCustomerChatInput {
  attachmentIds: [ID!]
  customerId: ID!
  text: String
  threadId: ID!

  """
  When provided, this will override the timestamp of the chat. Useful when backfilling messages. Must be in ISO 8601 format (e.g. 2024-10-28T18:30:00Z).
  """
  timestamp: String
}

type SendCustomerChatOutput {
  chat: Chat
  error: MutationError
}

input SendDiscordMessageInput {
  attachmentIds: [ID!]
  markdownContent: String
  threadId: ID!
}

type SendDiscordMessageOutput {
  discordMessage: DiscordMessage
  error: MutationError
}

input SendMSTeamsMessageInput {
  attachmentIds: [ID!]
  markdownContent: String
  mentions: [MentionInput!]
  threadId: ID!
}

type SendMSTeamsMessageOutput {
  error: MutationError
  msTeamsMessage: MSTeamsMessage
}

input SendNewEmailInput {
  additionalRecipients: [EmailParticipantInput!]
  attachmentIds: [ID!]
  customerId: ID!

  """
  Optional field for alternate from email address. If provided, it will be used as the from address in the email.
  It must match one of the workspace support email addresses (default or alternate).
  """
  fromAlternateSupportEmail: EmailParticipantInput
  hiddenRecipients: [EmailParticipantInput!]
  markdownContent: String
  subject: String!
  textContent: String!

  """
  If provided this will add the new email to an existing thread. If not provided, a new thread will be created.
  """
  threadId: ID
}

type SendNewEmailOutput {
  email: Email
  error: MutationError
}

input SendSlackMessageInput {
  attachmentIds: [ID!]
  markdownContent: String
  textContent: String @deprecated(reason: "Use markdownContent instead")
  threadId: ID!
  unfurlLinks: Boolean
}

type SendSlackMessageOutput {
  error: MutationError
}

input SendThreadDiscussionMessageInput {
  attachmentIds: [ID!]
  markdownContent: String!
  threadDiscussionId: ID!
}

type SendThreadDiscussionMessageOutput {
  error: MutationError
  threadDiscussionMessage: ThreadDiscussionMessage
}

enum SentimentType {
  NEGATIVE
  NEUTRAL
  POSITIVE
}

type ServiceAuthorization {
  connectedAt: DateTime!
  connectedBy: InternalActor!
  createdAt: DateTime!
  createdBy: InternalActor!
  id: ID!
  serviceIntegration: ServiceIntegration!
  status: ServiceAuthorizationStatus!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type ServiceAuthorizationConnection {
  edges: [ServiceAuthorizationEdge!]!
  pageInfo: PageInfo!
}

type ServiceAuthorizationConnectionDetails {
  hmacDigest: String!
  serviceAuthorizationId: ID!

  """
  One of: zendesk, salesforce, freshdesk, helpscout-mailbox, hubspot, jira, shortcut, rootly, incidentio, github-app-oauth.
  """
  serviceIntegrationKey: String!
}

type ServiceAuthorizationEdge {
  cursor: String!
  node: ServiceAuthorization!
}

"""
The status of the service authorization. The status transitions are as follows:
PENDING_AUTH  COMPLETE_AUTH  CONNECTED  REINSTALL_REQUIRED

There is no
"""
enum ServiceAuthorizationStatus {
  """
  User has completed the service authorization, but the service is not yet ready for use.
  This happens when the service requires additional configuration (e.g. creating webhooks
  in the service).
  This is a transient state that typically lasts for a few seconds. Plain will automatically
  attempt to configure the service, and transition to CONNECTED or REINSTALL_REQUIRED.
  """
  COMPLETED_AUTH

  """Service authorization is connected and ready for use."""
  CONNECTED

  """
  Service authorization was requested, but the user has not yet completed the authorization.
  """
  PENDING_AUTH

  """
  Service authorization was revoked, this typically happen when the Plain integration is removed
  from the service. Plain keeps the service authorization to allow for reconnection without
  losing the service's configuration.
  """
  REINSTALL_REQUIRED
}

input ServiceAuthorizationsFilter {
  """
  One of: zendesk, salesforce, freshdesk, helpscout-mailbox, hubspot, jira, shortcut, rootly, incidentio, github-app-oauth.
  """
  serviceIntegrationKey: String
}

interface ServiceIntegration {
  key: String!
  name: String!
}

interface ServiceLevelAgreement {
  """
  The actions to take when the SLA is about to breach and when it breaches.
  """
  breachActions: [BreachAction!]!
  createdAt: DateTime!
  createdBy: InternalActor!
  id: ID!

  """
  This SLA can only be applied to a thread if it has one of these label types.
  """
  threadLabelTypeIdFilter: ServiceLevelAgreementThreadLabelTypeIdFilter

  """
  This SLA can only be applied to a thread if it has one of these priority values.
  """
  threadPriorityFilter: [Int!]!
  updatedAt: DateTime!
  updatedBy: InternalActor!

  """
  If true, the SLA will only be tracked during your workspace's business hours. If false, the SLA will tracked 24/7.
  """
  useBusinessHoursOnly: Boolean!
}

input ServiceLevelAgreementFilter {
  statuses: [ServiceLevelAgreementStatus!]
  types: [ServiceLevelAgreementType!]
  updatedAt: DatetimeFilter
}

input ServiceLevelAgreementInput {
  """
  The actions to take when the SLA is about to breach and when it breaches.
  """
  breachActions: [BreachActionInput!]!

  """Set this to configure the firt response time SLA."""
  firstResponseTimeMinutes: Int

  """Set this to configure an SLA for next responses."""
  nextResponseTimeMinutes: Int

  """
  This SLA can only be applied to a thread if it has one or all of these label types. If not provided, the filter is not applied.
  """
  threadLabelTypeIdFilter: ServiceLevelAgreementThreadLabelTypeIdFilterInput

  """
  This SLA can only be applied to a thread if it has one of these priority values. If not provided, it defaults to all priorities (0, 1, 2 and 3).
  """
  threadPriorityFilter: [Int!]

  """
  If true, the SLA will only be tracked during your workspace's business hours. If false, the SLA will tracked 24/7.
  """
  useBusinessHoursOnly: Boolean!
}

enum ServiceLevelAgreementStatus {
  ACHIEVED
  BREACHED
  BREACHING
  CANCELLED
  IMMINENT_BREACH
  PENDING
}

union ServiceLevelAgreementStatusDetail = ServiceLevelAgreementStatusDetailAchieved | ServiceLevelAgreementStatusDetailBreached | ServiceLevelAgreementStatusDetailBreaching | ServiceLevelAgreementStatusDetailCancelled | ServiceLevelAgreementStatusDetailImminentBreach | ServiceLevelAgreementStatusDetailPending

type ServiceLevelAgreementStatusDetailAchieved {
  """The time when this SLA was achieved."""
  achievedAt: DateTime!
}

type ServiceLevelAgreementStatusDetailBreached {
  """The time when this SLA breached."""
  breachedAt: DateTime!

  """The time when we completed this breached SLA."""
  completedAt: DateTime!
}

type ServiceLevelAgreementStatusDetailBreaching {
  """The time when this SLA breached."""
  breachedAt: DateTime!
}

type ServiceLevelAgreementStatusDetailCancelled {
  """The time when this SLA was cancelled."""
  cancelledAt: DateTime!
}

type ServiceLevelAgreementStatusDetailImminentBreach {
  """The time when this SLA will breach."""
  breachingAt: DateTime!
}

type ServiceLevelAgreementStatusDetailPending {
  """The time when this SLA will breach."""
  breachingAt: DateTime!
}

type ServiceLevelAgreementStatusSummary {
  firstResponseTime: ServiceLevelAgreementStatusDetail
  nextResponseTime: ServiceLevelAgreementStatusDetail
}

type ServiceLevelAgreementStatusTransitionedEntry {
  nextStatus: ServiceLevelAgreementStatus!
  previousStatus: ServiceLevelAgreementStatus!
  serviceLevelAgreement: ServiceLevelAgreement
}

type ServiceLevelAgreementThreadLabelTypeIdFilter {
  """
  The label type IDs that the thread needs to have in order for the SLA to be applied. Based on the 'requireAll' field.
  """
  labelTypeIds: [ID!]!

  """
  If true, the SLA will only be applied to threads that have all of the provided label types. If false, the SLA will be applied to threads that have any of the provided label types.
  """
  requireAll: Boolean!
}

input ServiceLevelAgreementThreadLabelTypeIdFilterInput {
  """
  The label type IDs that the thread needs to have in order for the SLA to be applied. Based on the 'requireAll' field.
  """
  labelTypeIds: [ID!]!

  """
  If true, the SLA will only be applied to threads that have all of the provided label types. If false, the SLA will be applied to threads that have any of the provided label types.
  """
  requireAll: Boolean!
}

enum ServiceLevelAgreementType {
  FIRST_RESPONSE_TIME
  NEXT_RESPONSE_TIME
}

input SetCustomerTenantsInput {
  customerIdentifier: CustomerIdentifierInput!
  tenantIdentifiers: [TenantIdentifierInput!]!
}

type SetCustomerTenantsOutput {
  customer: Customer
  error: MutationError
}

"""A union of different types of settings."""
union Setting = BooleanSetting | NumberSetting | StringArraySetting | StringSetting

type SettingScope {
  id: ID
  scopeType: SettingScopeType!
}

"""An input to specify the scope for a setting."""
input SettingScopeInput {
  """
  An optional ID input. Depends on the type of scope if this is required.
  """
  id: ID

  """Determines the type of the scope."""
  scopeType: SettingScopeType!
}

"""An enum to describe the type of scope the setting is for."""
enum SettingScopeType {
  """
  Scope for any chat application settings
  An `id` is mandatory and should be a chat application id (`liveChatApp_123`)
  """
  CHAT

  """
  Scope for any user level settings
  An `id` is not needed as it will implicitly be the authenticated user's id.
  """
  USER

  """
  Scope for the authenticated user's email notification settings.
  An `id` is not needed as it will implicitly be the authenticated user's id.
  """
  USER_EMAIL_NOTIFICATIONS

  """
  Scope for the authenticated user's slack notification settings.
  An `id` is not needed as it will implicitly be the authenticated user's id.
  """
  USER_SLACK_NOTIFICATIONS

  """
  Scope for workspace level settings for the whole workspace.
  An `id` is not needed as it will implicitly be the current workspace id.
  """
  WORKSPACE

  """
  Scope for discord notifications configured for the whole workspace.
  An `id` is mandatory and should be a workspace discord integration id (`wsDiscordInt_123`)
  """
  WORKSPACE_DISCORD_NOTIFICATIONS

  """
  Scope for slack support channel settings.
  An `id` is mandatory and should be a workspace slack channel integration id (`wsSlackInt_123`)
  """
  WORKSPACE_SLACK_CHANNEL

  """
  Scope for slack notifications configured for the whole workspace.
  An `id` is mandatory and should be a workspace slack integration id (`wsSlackInt_123`)
  """
  WORKSPACE_SLACK_NOTIFICATIONS
}

"""
An input "union" where exactly one field may be be provided as an input.
Current API only supports booleans but as the API expands more optional fields will be added.
"""
input SettingValueInput {
  """If the setting value is a boolean then this field should be set."""
  boolean: Boolean

  """If the setting value is a number then this field should be set"""
  number: Int

  """If the setting value is a string then this field should be set."""
  string: String

  """If the setting value is a string array then this field should be set."""
  stringArray: [String]
}

input SetupTenantFieldSchemaMappingInput {
  mapsTo: TenantFieldMappingConcept!
  tenantFieldSchemaId: ID!
}

type SetupTenantFieldSchemaMappingOutput {
  error: MutationError
  tenantFieldSchema: TenantFieldSchema
}

input ShareThreadToUserInSlackInput {
  threadId: ID!
  userId: ID!
}

type ShareThreadToUserInSlackOutput {
  error: MutationError
}

type SingleValueMetric {
  values: [SingleValueMetricValue!]!
}

input SingleValueMetricFilters {
  csatRating: Int
  csatSurveyId: ID
  userId: ID
}

input SingleValueMetricOptions {
  dimension: MetricDimensionType
  filters: SingleValueMetricFilters

  """Defaults to 24 hours ago."""
  from: String
  subDimension: String
  to: String
}

type SingleValueMetricValue {
  dimension: MetricDimension
  userId: ID
  value: Float
}

type SlackChannelMembership {
  slackChannelId: ID!
}

type SlackCustomerIdentity {
  slackUserId: String!
}

type SlackMessageEntry {
  attachments: [Attachment!]!
  customerId: ID!
  deletedOnSlackAt: DateTime
  lastEditedOnSlackAt: DateTime
  reactions: [SlackReaction!]!
  relatedThread: SlackMessageEntryRelatedThread
  slackMessageLink: String
  slackWebMessageLink: String!
  text: String!
}

type SlackMessageEntryRelatedThread {
  threadId: ID!
}

type SlackReaction {
  actors: [Actor!]!
  imageUrl: String
  name: String!
}

type SlackReplyEntry {
  attachments: [Attachment!]!
  customerId: ID!
  deletedOnSlackAt: DateTime
  lastEditedOnSlackAt: DateTime
  reactions: [SlackReaction!]!
  slackMessageLink: String
  slackWebMessageLink: String!
  text: String!
}

type SlackThreadChannelAssociation implements ThreadChannelAssociation {
  companyId: ID
  connectedSlackChannelId: ID!
  createdAt: DateTime!
  createdBy: InternalActor!
  id: ID!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type SlackThreadChannelDetails {
  slackChannelId: String!
  slackChannelName: String!
  slackTeamId: String!
  slackTeamName: String!
}

input SlackThreadChannelDetailsInput {
  slackChannelId: ID!
  slackTeamId: ID!
}

type SlackUser {
  createdAt: DateTime!
  createdBy: InternalActor!
  fullName: String!
  id: ID!
  isInChannel: Boolean!
  slackAvatarUrl72px: String
  slackHandle: String!
  slackUserId: ID!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type SlackUserConnection {
  edges: [SlackUserEdge!]!
  pageInfo: PageInfo!
}

type SlackUserEdge {
  cursor: String!
  node: SlackUser!
}

type SlackUserIdentity {
  slackTeamId: String!
  slackUserId: String!
}

type Snippet {
  createdAt: DateTime!
  createdBy: InternalActor!
  deletedAt: DateTime
  deletedBy: InternalActor
  id: ID!
  isDeleted: Boolean!
  markdown: String
  name: String!
  path: String
  text: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type SnippetConnection {
  edges: [SnippetEdge!]!
  pageInfo: PageInfo!
}

type SnippetEdge {
  cursor: String!
  node: Snippet!
}

enum SnoozeStatusDetail {
  WAITING_FOR_CUSTOMER
  WAITING_FOR_DURATION
}

input SnoozeThreadInput {
  durationSeconds: Int
  statusDetail: SnoozeStatusDetail
  threadId: ID!
}

type SnoozeThreadOutput {
  error: MutationError
  thread: Thread
}

enum SortDirection {
  ASC
  DESC
}

input StartServiceAuthorizationInput {
  """
  One of: zendesk, salesforce, freshdesk, helpscout-mailbox, hubspot, jira, shortcut, rootly, incidentio, github-app-oauth.
  """
  serviceIntegrationKey: String!
}

type StartServiceAuthorizationOutput {
  connectionDetails: ServiceAuthorizationConnectionDetails
  error: MutationError
}

enum StatusDetailType {
  CREATED
  DONE_AUTOMATICALLY_SET
  DONE_MANUALLY_SET
  IGNORED
  IN_PROGRESS
  NEW_REPLY
  THREAD_DISCUSSION_RESOLVED
  THREAD_LINK_UPDATED
  TIMER_EXPIRED @deprecated(reason: "Use DONE_AUTOMATICALLY_SET instead.")
  WAITING_FOR_CUSTOMER
  WAITING_FOR_DURATION
}

"""A string array setting"""
type StringArraySetting {
  """The setting code."""
  code: String!

  """The scope of the setting."""
  scope: SettingScope!

  """
  The value of the setting. This is named uniquely (instead of just `value`) so that the union has unique fields.
  """
  stringArrayValue: [String!]!
}

input StringInput {
  value: String!
}

"""
The different ways in which a string is matched.
Exactly one of these must be provided in a single search expression.
"""
input StringSearchExpression {
  """Case-insensitive match values containing the provided string."""
  caseInsensitiveContains: String
}

"""A string setting"""
type StringSetting {
  """The setting code."""
  code: String!

  """The scope of the setting."""
  scope: SettingScope!

  """
  The value of the setting. This is named uniquely (instead of just `value`) so that the union has unique fields.
  """
  stringValue: String!
}

type Subscription {
  customerCardInstanceChanges(customerId: ID!): CustomerCardInstanceChangesResult!
  customerChanges(filters: CustomerChangesFilter @deprecated): CustomerChange!
  threadChanges: ThreadChange!
  threadFieldSchemaChanges: ThreadFieldSchemaChange!
  threadTimelineChanges(threadId: ID!): TimelineEntryChange!
  timelineChanges(customerId: ID!): TimelineEntryChange!
  userChanges: UserChange!
}

type SubscriptionAcknowledgement {
  subscriptionId: ID!
}

type SubscriptionEventType {
  description: String!
  eventType: String!
}

type SupportEmailAddressEmailActor {
  supportEmailAddress: String!
}

type SurveyResponse {
  comment: String
  createdAt: DateTime!
  createdBy: Actor!
  id: ID!
  rating: Int
  respondedAt: DateTime
  sentiment: SentimentType
  surveyId: ID
  updatedAt: DateTime!
  updatedBy: Actor!
}

input SurveyResponseFilter {
  """
  Filter for threads with any survey response, regardless of the specific values
  """
  hasResponse: Boolean
  rating: Int
  responseAt: DatetimeFilter
  sentiment: SentimentType
  surveyId: ID
}

input SyncBusinessHoursSlotsInput {
  slots: [BusinessHoursSlotInput!]!
}

type SyncBusinessHoursSlotsOutput {
  error: MutationError
  slots: [BusinessHoursSlot!]!
}

type System {
  id: ID!
}

type SystemActor {
  systemId: ID!
}

type Tenant {
  createdAt: DateTime!
  createdBy: InternalActor!
  externalId: String!
  id: ID!
  name: String!
  source: TenantSource!
  tenantFields: [TenantField!]!
  tier: Tier
  updatedAt: DateTime!
  updatedBy: InternalActor!
  url: String
}

type TenantConnection {
  edges: [TenantEdge!]!
  pageInfo: PageInfo!
}

type TenantEdge {
  cursor: String!
  node: Tenant!
}

type TenantField {
  createdAt: DateTime!
  createdBy: InternalActor!
  externalFieldId: ID!
  id: ID!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  value: TenantFieldValue!
}

type TenantFieldBooleanValue {
  booleanValue: Boolean!
}

type TenantFieldDateTimeValue {
  dateValue: DateTime!
}

input TenantFieldFilter {
  booleanValue: Boolean
  dateValue: String
  externalFieldId: String!
  numberValue: Float
  stringArrayValue: [String!]
  stringValue: String
}

input TenantFieldIdentifier {
  externalFieldId: ID!
  tenantId: ID!
}

enum TenantFieldMappingConcept {
  TIER
}

type TenantFieldNumberValue {
  numberValue: Float!
}

type TenantFieldSchema {
  createdAt: DateTime!
  createdBy: InternalActor!
  externalFieldId: ID!
  id: ID!
  isVisible: Boolean!
  label: String!

  """
  The concept this field maps to, if any. Used for automatic tier assignment.
  """
  mapsTo: TenantFieldMappingConcept
  options: [String!]
  order: Int!
  source: String!
  type: TenantFieldType!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type TenantFieldSchemaConnection {
  edges: [TenantFieldSchemaEdge!]!
  pageInfo: PageInfo!
}

type TenantFieldSchemaEdge {
  cursor: String!
  node: TenantFieldSchema!
}

input TenantFieldSchemaInput {
  externalFieldId: ID!
  isVisible: Boolean!
  label: String!
  options: [String!]
  order: Int!
  source: String!
  type: TenantFieldType!
}

input TenantFieldSchemasFilter {
  source: String
}

type TenantFieldStringArrayValue {
  arrayValue: [String!]!
}

type TenantFieldStringValue {
  stringValue: String!
}

enum TenantFieldType {
  BOOLEAN_TYPE
  DATETIME_TYPE
  NUMBER_TYPE
  STRING_ARRAY
  STRING_TYPE
}

union TenantFieldValue = TenantFieldBooleanValue | TenantFieldDateTimeValue | TenantFieldNumberValue | TenantFieldStringArrayValue | TenantFieldStringValue

input TenantIdentifierInput {
  externalId: String
  tenantId: ID
}

type TenantSearchResult {
  tenant: Tenant!
}

type TenantSearchResultConnection {
  edges: [TenantSearchResultEdge!]!
  pageInfo: PageInfo!
}

type TenantSearchResultEdge {
  cursor: String!
  node: TenantSearchResult!
}

enum TenantSource {
  API
  HUBSPOT
  SALESFORCE
}

type TenantTierMembership {
  createdAt: DateTime!
  createdBy: InternalActor!
  id: ID!
  tenantId: ID!
  tierId: ID!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

"""Query to search for tenants."""
input TenantsSearchQuery {
  """
  The term to search for. It must be at least 2 characters long. The search is case-insensitive on these two fields:
  - the tenant name (partial match)
  - the tenant external id (exact match)
  """
  term: String!
}

"""
A thread represents a conversation with a customer, around a specific topic.
"""
type Thread {
  """Additional assignees for this thread."""
  additionalAssignees: [ThreadAssignee!]!

  """
  The datetime when this thread was last assigned to someone or something.
  """
  assignedAt: DateTime

  """Who or what this thread is assigned to."""
  assignedTo: ThreadAssignee

  """The channel this thread belongs to."""
  channel: ThreadChannel!

  """Details about the channel this thread is on."""
  channelDetails: ThreadChannelDetails

  """The datetime when this thread was created."""
  createdAt: DateTime!

  """The actor who created this thread."""
  createdBy: Actor!

  """The customer involved in this thread."""
  customer: Customer!

  """The description of this thread."""
  description: String

  """The escalation details for this thread."""
  escalationDetails: ThreadEscalationDetails

  """
  The external ID of this thread. You can use this field to store your own unique identifier for this thread.
  """
  externalId: ID

  """First inbound message on the thread."""
  firstInboundMessageInfo: ThreadMessageInfo

  """First outbound message on the thread."""
  firstOutboundMessageInfo: ThreadMessageInfo

  """The unique identifier of the thread."""
  id: ID!

  """The labels attached to this thread."""
  labels: [Label!]!

  """Last inbound message received."""
  lastInboundMessageInfo: ThreadMessageInfo

  """Last outbound message received."""
  lastOutboundMessageInfo: ThreadMessageInfo

  """The links attached to this thread."""
  links(after: String, before: String, first: Int, last: Int): ThreadLinkConnection!

  """The participants in this thread."""
  participants(after: String, before: String, first: Int, last: Int): ActorConnection!

  """
  The preview text of the thread reflects the current state of the thread. As such, it might be updated when new activity happens in the thread.
  """
  previewText: String

  """
  The priority of the thread. Valid values are 0, 1, 2, 3, from most to least urgent.
  """
  priority: Int!

  """The human-readable identifier of the thread, ie T-1234."""
  ref: String!

  """
  If this thread has a linked SLA, this will inform on the status of its objectives.
  """
  serviceLevelAgreementStatusSummary: ServiceLevelAgreementStatusSummary!

  """The status of this thread."""
  status: ThreadStatus!

  """The datetime when the status of this thread was last changed."""
  statusChangedAt: DateTime!

  """The actor who last changed the status of this thread."""
  statusChangedBy: Actor!

  """
  Additional details about the current thread status. For instance, how long it will be snoozed for.
  """
  statusDetail: ThreadStatusDetail

  """
  The support email addresses involved in this thread.
  A support email address is either the default support email address or an alternate support email address.
  A support email address is considered to be involved in a thread when any participant in the thread uses it as their email recipient.
  """
  supportEmailAddresses: [String!]!

  """The survey responses for this thread."""
  surveyResponse: SurveyResponse

  """The tenant this thread is associated with."""
  tenant: Tenant

  """The thread discussions attached to this thread."""
  threadDiscussions: [ThreadDiscussion!]!

  """The thread fields attached to this thread."""
  threadFields: [ThreadField!]!

  """
  The tier this thread is associated with. Tiers mandate the SLAs for this thread.
  """
  tier: Tier

  """All of the timeline entries in this thread."""
  timelineEntries(after: String, before: String, filters: ThreadTimelineEntriesFilter, first: Int, last: Int): TimelineEntryConnection!

  """
  The title of this thread, which allows to quickly identify what it is about.
  """
  title: String!

  """The datetime when this thread was last updated."""
  updatedAt: DateTime!

  """The actor who last updated this thread."""
  updatedBy: Actor!
}

type ThreadAdditionalAssigneesTransitionedEntry {
  nextAssignees: [ThreadAssignee!]!
  previousAssignees: [ThreadAssignee!]!
}

union ThreadAssignee = MachineUser | System | User

input ThreadAssigneeInput {
  machineUserId: ID
  userId: ID
}

type ThreadAssignmentTransitionedEntry {
  nextAssignee: ThreadAssignee
  previousAssignee: ThreadAssignee
}

type ThreadChange {
  changeType: ChangeType!
  thread: Thread!
}

enum ThreadChannel {
  API
  CHAT
  DISCORD
  EMAIL
  IMPORT
  MS_TEAMS
  SLACK
}

interface ThreadChannelAssociation {
  companyId: ID
  createdAt: DateTime!
  createdBy: InternalActor!
  id: ID!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

union ThreadChannelDetails = ChatThreadChannelDetails | DiscordThreadChannelDetails | ImportThreadChannelDetails | MSTeamsThreadChannelDetails | SlackThreadChannelDetails

input ThreadChannelDetailsInput {
  msTeams: MSTeamsThreadChannelDetailsInput
  slack: SlackThreadChannelDetailsInput
}

type ThreadCluster {
  category: String!
  confidence: Float
  createdAt: DateTime!
  createdBy: Actor!
  description: String!
  emoji: String!
  id: ID!
  sentiment: String!
  threads: [MinimalThreadWithDistance!]!
  title: String!
  updatedAt: DateTime!
  updatedBy: Actor!
}

type ThreadClusterConnection {
  edges: [ThreadClusterEdge!]!
  pageInfo: PageInfo!
}

type ThreadClusterEdge {
  cursor: String!
  node: ThreadCluster!
}

input ThreadClustersFilter {
  variant: String
}

type ThreadConnection {
  edges: [ThreadEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ThreadDiscussion {
  createdAt: DateTime!
  createdBy: Actor!
  emailRecipients: [String!]!
  id: ID!
  messages(after: String, before: String, first: Int, last: Int): ThreadDiscussionMessageConnection!
  resolvedAt: DateTime
  slackChannelId: String
  slackChannelName: String
  slackMessageLink: String
  slackTeamId: String
  threadId: ID!
  title: String!
  type: ThreadDiscussionType!
  updatedAt: DateTime!
  updatedBy: Actor!
}

input ThreadDiscussionEmailDetailsInput {
  ccAddresses: [String!]
  toAddresses: [String!]!
}

type ThreadDiscussionEntry {
  customerId: ID!
  discussionType: ThreadDiscussionType!
  emailRecipients: [String!]!
  slackChannelName: String
  slackMessageLink: String
  threadDiscussionId: ID!
}

type ThreadDiscussionMessage {
  attachments: [Attachment!]!
  createdAt: DateTime!
  createdBy: Actor!
  deletedOnSlackAt: DateTime
  id: ID!
  lastEditedOnSlackAt: DateTime
  reactions: [ThreadDiscussionMessageReaction!]!
  slackMessageLink: String
  text: String!
  threadDiscussionId: ID!
  updatedAt: DateTime!
  updatedBy: Actor!
}

type ThreadDiscussionMessageConnection {
  edges: [ThreadDiscussionMessageEdge!]!
  pageInfo: PageInfo!
}

type ThreadDiscussionMessageEdge {
  cursor: String!
  node: ThreadDiscussionMessage!
}

type ThreadDiscussionMessageReaction {
  actors: [Actor!]!
  imageUrl: String
  name: String!
}

type ThreadDiscussionResolvedEntry {
  customerId: ID!
  discussionType: ThreadDiscussionType!
  emailRecipients: [String!]!
  resolvedAt: DateTime!
  slackChannelName: String
  slackMessageLink: String
  threadDiscussionId: ID!
}

input ThreadDiscussionSlackDetailsInput {
  connectedSlackChannelId: ID!
}

enum ThreadDiscussionType {
  EMAIL
  SLACK
}

type ThreadEdge {
  cursor: String!
  node: Thread!
}

type ThreadEscalationDetails {
  """The escalation path this thread is associated with."""
  escalationPath: EscalationPath!

  """
  The step this thread will be escalated to. If it is null, the thread is at the end of the escalation path.
  """
  nextEscalationPathStep: EscalationPathStep
}

type ThreadEvent {
  """The list of components of the event."""
  components: [EventComponent!]!

  """The datetime when this event was created."""
  createdAt: DateTime!

  """The actor who created this event."""
  createdBy: Actor!

  """The customer that this event belongs to."""
  customerId: ID!

  """The ID of the event."""
  id: ID!

  """The thread that this event belongs to."""
  threadId: ID!

  """The title of the event."""
  title: String!

  """The datetime when this event was last updated."""
  updatedAt: DateTime!

  """The actor who last updated this event."""
  updatedBy: Actor!
}

type ThreadEventEntry implements TimelineEventEntry {
  components: [EventComponent!]!
  customerId: ID!
  externalId: ID
  timelineEventId: ID!
  title: String!
}

type ThreadField {
  booleanValue: Boolean
  createdAt: DateTime!
  createdBy: Actor!
  id: ID!
  isAiGenerated: Boolean!
  key: String!
  stringValue: String
  threadId: ID!
  type: ThreadFieldSchemaType!
  updatedAt: DateTime!
  updatedBy: Actor!
}

input ThreadFieldFilter {
  booleanValue: Boolean
  key: String!
  stringValue: String
}

type ThreadFieldSchema {
  createdAt: DateTime!
  createdBy: InternalActor!
  defaultBooleanValue: Boolean
  defaultStringValue: String
  dependsOnLabels: [DependsOnLabelType!]!
  dependsOnThreadField: DependsOnThreadFieldType
  description: String!
  enumValues: [String!]!
  id: ID!
  isAiAutoFillEnabled: Boolean!
  isRequired: Boolean!
  key: String!
  label: String!
  order: Int!
  type: ThreadFieldSchemaType!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type ThreadFieldSchemaChange {
  changeType: ChangeType!
  threadFieldSchema: ThreadFieldSchema!
}

type ThreadFieldSchemaConnection {
  edges: [ThreadFieldSchemaEdge!]!
  pageInfo: PageInfo!
}

type ThreadFieldSchemaEdge {
  cursor: String!
  node: ThreadFieldSchema!
}

input ThreadFieldSchemaOrderInput {
  order: Int!
  threadFieldSchemaId: ID!
}

enum ThreadFieldSchemaType {
  BOOL
  ENUM
  STRING
}

type ThreadLabelsChangedEntry {
  nextLabels: [Label!]!
  previousLabels: [Label!]!
}

interface ThreadLink {
  createdAt: DateTime!
  createdBy: InternalActor!
  description: String
  id: ID!
  sourceId: String!
  sourceType: String!
  status: ThreadLinkStatus!
  threadId: ID!
  title: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  url: String!
}

type ThreadLinkCandidate {
  description: String
  sourceId: String!
  sourceStatus: ThreadLinkSourceStatus
  sourceType: String!
  status: ThreadLinkStatus!
  title: String!
  url: String!
}

type ThreadLinkCandidateConnection {
  edges: [ThreadLinkCandidateEdge!]!
  pageInfo: PageInfo!
}

type ThreadLinkCandidateEdge {
  cursor: String!
  node: ThreadLinkCandidate!
}

input ThreadLinkCandidateFilter {
  sourceType: String!
}

type ThreadLinkConnection {
  edges: [ThreadLinkEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

type ThreadLinkEdge {
  cursor: String!
  node: ThreadLink!
}

type ThreadLinkGroup {
  companyMetrics: ThreadLinkGroupCompanyMetrics!

  """
  The current rank of the thread link group considering groups
  which match the non-ID input filters.
  """
  currentViewRank: Int!

  """
  The default rank of the thread link group which takes into account
  only active groups. This rank is not affected by input filters.
  """
  defaultViewRank: Int
  id: ID!
  threadLinks(after: String, before: String, first: Int, last: Int): ThreadLinkConnection!
  threads(after: String, before: String, first: Int, last: Int): ThreadConnection!
  tierMetrics: ThreadLinkGroupTierMetrics!
}

type ThreadLinkGroupAggregateMetrics {
  totalCount: Int!
}

type ThreadLinkGroupCompanyMetrics {
  byCompany: [ThreadLinkGroupSingleCompanyMetrics!]!

  """Metrics when the thread is not associated with any company."""
  noCompany: ThreadLinkGroupAggregateMetrics!
}

type ThreadLinkGroupConnection {
  edges: [ThreadLinkGroupEdge!]!
  pageInfo: PageInfo!
}

type ThreadLinkGroupEdge {
  cursor: String!
  node: ThreadLinkGroup!
}

input ThreadLinkGroupFilter {
  companyIds: [ID!]

  """Defaults to [TODO, IN_PROGRESS]"""
  statuses: [ThreadLinkStatus!]
  threadLinkGroupIds: [ID!]
  tierIds: [ID!]
}

type ThreadLinkGroupSingleCompanyMetrics {
  company: Company!
  metrics: ThreadLinkGroupAggregateMetrics!
}

type ThreadLinkGroupSingleTierMetrics {
  metrics: ThreadLinkGroupAggregateMetrics!
  tier: Tier!
}

type ThreadLinkGroupTierMetrics {
  byTier: [ThreadLinkGroupSingleTierMetrics!]!

  """Metrics when the thread is not associated with any tier."""
  noTier: ThreadLinkGroupAggregateMetrics!
}

type ThreadLinkSourceStatus {
  color: String
  icon: String
  key: String!
  label: String!
}

"""
Represents a simplified, high-level status of a thread link which can be used for filtering and sorting.
Statuses from different external providers (e.g. Linear, Jira, Incident.io, Notion... etc) are mapped to one of these values.
"""
enum ThreadLinkStatus {
  """
  Indicates that the linked issue is in a state that is considered finished.
  This includes granular statuses like "Completed", "Done", "Resolved", "Cancelled", ...etc.
  """
  DONE

  """
  Indicates that the linked entity is in a post-start state, but not yet finished.
  This includes granular statuses like "Started", "In Progress", "In Review", "Blocked", ...etc
  """
  IN_PROGRESS

  """
  Indicates that the linked entity is in pre-start state.
  This includes granular statuses like "Backlog", "Triage", "Unstarted", "Draft", "Planned", ...etc
  """
  TODO

  """Unknown or unsupported future statuses from external providers."""
  UNKNOWN
}

type ThreadLinkUpdatedEntry {
  previousThreadLink: ThreadLink!
  threadLink: ThreadLink!
}

type ThreadMessageInfo {
  """The source through which the message came through."""
  messageSource: MessageSource!

  """The datetime when the last message was received."""
  timestamp: DateTime!
}

type ThreadPriorityChangedEntry {
  nextPriority: Int!
  previousPriority: Int!
}

type ThreadSearchResult {
  thread: Thread!
}

type ThreadSearchResultConnection {
  edges: [ThreadSearchResultEdge!]!
  pageInfo: PageInfo!
}

type ThreadSearchResultEdge {
  cursor: String!
  node: ThreadSearchResult!
}

enum ThreadStatus {
  DONE
  SNOOZED
  TODO
}

union ThreadStatusDetail = ThreadStatusDetailCreated | ThreadStatusDetailDoneAutomaticallySet | ThreadStatusDetailDoneManuallySet | ThreadStatusDetailIgnored | ThreadStatusDetailInProgress | ThreadStatusDetailLinearUpdated | ThreadStatusDetailNewReply | ThreadStatusDetailReplied | ThreadStatusDetailSnoozed | ThreadStatusDetailThreadDiscussionResolved | ThreadStatusDetailThreadLinkUpdated | ThreadStatusDetailUnsnoozed | ThreadStatusDetailWaitingForCustomer | ThreadStatusDetailWaitingForDuration

type ThreadStatusDetailCreated {
  createdAt: DateTime!
  statusChangedAt: DateTime!
}

type ThreadStatusDetailDoneAutomaticallySet {
  afterSeconds: Int
  statusChangedAt: DateTime!
}

type ThreadStatusDetailDoneManuallySet {
  statusChangedAt: DateTime!
}

type ThreadStatusDetailIgnored {
  statusChangedAt: DateTime!
}

type ThreadStatusDetailInProgress {
  statusChangedAt: DateTime!
}

type ThreadStatusDetailLinearUpdated {
  linearIssueId: ID! @deprecated(reason: "ThreadStatusDetailLinearUpdated is no longer supported, query ThreadStatusDetailThreadLinkUpdated instead.")
  statusChangedAt: DateTime! @deprecated(reason: "ThreadStatusDetailLinearUpdated is no longer supported, query ThreadStatusDetailThreadLinkUpdated instead.")
  updatedAt: DateTime! @deprecated(reason: "ThreadStatusDetailLinearUpdated is no longer supported, query ThreadStatusDetailThreadLinkUpdated instead.")
}

type ThreadStatusDetailNewReply {
  newReplyAt: DateTime @deprecated(reason: "newReplyAt is no longer supported, query Thread.lastInboundMessageInfo.timestamp instead.")
  statusChangedAt: DateTime!
}

type ThreadStatusDetailReplied {
  repliedAt: DateTime! @deprecated(reason: "ThreadStatusDetailReplied is no longer supported.")
  statusChangedAt: DateTime! @deprecated(reason: "ThreadStatusDetailReplied is no longer supported.")
}

type ThreadStatusDetailSnoozed {
  snoozedAt: DateTime! @deprecated(reason: "ThreadStatusDetailSnoozed is no longer supported.")
  snoozedUntil: DateTime! @deprecated(reason: "ThreadStatusDetailSnoozed is no longer supported.")
  statusChangedAt: DateTime! @deprecated(reason: "ThreadStatusDetailSnoozed is no longer supported.")
}

type ThreadStatusDetailThreadDiscussionResolved {
  statusChangedAt: DateTime!
  threadDiscussionId: ID
}

type ThreadStatusDetailThreadLinkUpdated {
  linearIssueId: ID
  statusChangedAt: DateTime!
  updatedAt: DateTime! @deprecated(reason: "Use statusChangedAt instead")
}

type ThreadStatusDetailUnsnoozed {
  snoozedAt: DateTime! @deprecated(reason: "ThreadStatusDetailUnsnoozed is no longer supported.")
  statusChangedAt: DateTime! @deprecated(reason: "ThreadStatusDetailUnsnoozed is no longer supported.")
}

type ThreadStatusDetailWaitingForCustomer {
  statusChangedAt: DateTime!
}

type ThreadStatusDetailWaitingForDuration {
  statusChangedAt: DateTime!
  waitingUntil: DateTime!
}

type ThreadStatusTransitionedEntry {
  nextStatus: ThreadStatus!
  nextStatusDetail: ThreadStatusDetail
  previousStatus: ThreadStatus!
  previousStatusDetail: ThreadStatusDetail
}

input ThreadTimelineEntriesFilter {
  """Only return message timeline entries."""
  isMessage: Boolean
}

type ThreadWithDistance {
  distance: Float!
  thread: Thread!
}

type ThreadsDisplayOptions {
  hasAssignees: Boolean!
  hasChannels: Boolean!
  hasCompany: Boolean!
  hasCustomer: Boolean!
  hasCustomerGroups: Boolean!
  hasIssueTrackerIssues: Boolean!
  hasJiraIssues: Boolean! @deprecated(reason: "Use hasIssueTrackerIssues instead")
  hasLabels: Boolean!
  hasLastUpdated: Boolean!
  hasLinearIssues: Boolean! @deprecated(reason: "Use hasIssueTrackerIssues instead")
  hasLinkedThreads: Boolean!
  hasPreviewText: Boolean!
  hasServiceLevelAgreements: Boolean!
  hasStatus: Boolean!
  hasTier: Boolean!
}

input ThreadsDisplayOptionsInput {
  hasAssignees: Boolean!
  hasChannels: Boolean!
  hasCompany: Boolean!
  hasCustomer: Boolean!
  hasCustomerGroups: Boolean!
  hasIssueTrackerIssues: Boolean
  hasJiraIssues: Boolean @deprecated(reason: "Use hasIssueTrackerIssues instead")
  hasLabels: Boolean!
  hasLastUpdated: Boolean!
  hasLinearIssues: Boolean @deprecated(reason: "Use hasIssueTrackerIssues instead")
  hasLinkedThreads: Boolean!
  hasPreviewText: Boolean!
  hasServiceLevelAgreements: Boolean!
  hasStatus: Boolean!
  hasTier: Boolean!
}

input ThreadsFilter {
  assignedToUser: [ID!]
  companyIdentifiers: [CompanyIdentifierInput!]
  createdAt: DatetimeFilter
  customerGroupIdentifiers: [CustomerGroupIdentifier!]
  customerIds: [ID!]
  isAssigned: Boolean
  isMarkedAsSpam: Boolean
  labelTypeIds: [ID!]
  messageSource: [MessageSource!]
  participantIds: [ID!]
  priorities: [Int!]
  refs: [String!]
  serviceLevelAgreements: ServiceLevelAgreementFilter
  statusChangedAt: DatetimeFilter
  statusDetails: [StatusDetailType!]
  statuses: [ThreadStatus!]
  supportEmailAddresses: [String!]
  surveyResponse: SurveyResponseFilter
  tenantFields: [TenantFieldFilter!]
  tenantIdentifiers: [TenantIdentifierInput!]
  threadFields: [ThreadFieldFilter!]
  threadIds: [ID!]
  threadLinkGroupIds: [ID!]
  tierIdentifiers: [TierIdentifierInput!]
  updatedAt: DatetimeFilter
}

enum ThreadsGroupBy {
  ASSIGNEE
  CHANNEL
  COMPANY
  CUSTOMER_GROUP
  LABEL
  NONE
  PRIORITY
  STATUS
  TENANT
  TIER
}

enum ThreadsLayout {
  BOARD
  TABLE
}

"""
Query to search for threads. The search term provided is used to match against different parts of the thread:
- its title
- its messages
- the customer's name
- the customer's email
"""
input ThreadsSearchQuery {
  """
  The term to search for. It must be at least 2 characters long. The search is case-insensitive.
  """
  term: String!
}

input ThreadsSort {
  direction: SortDirection!
  field: ThreadsSortField!
}

enum ThreadsSortField {
  CLOSEST_TO_BREACH_SLA
  CREATED_AT
  LAST_INBOUND_MESSAGE_AT
  PRIORITY
  STATUS_CHANGED_AT
}

type Tier {
  """
  The color to assign to this tier, given by its hex code (e.g. #FABADA). This color is used in Plain's UI to represent this tier.
  """
  color: String!
  createdAt: DateTime!
  createdBy: InternalActor!

  """
  Any thread created in this tier will have this priority by default, unless a different priority is specified while creating it.
  """
  defaultPriority: Int! @deprecated(reason: "Use defaultThreadPriority instead.")

  """
  Any thread created in this tier will have this priority by default, unless a different priority is specified while creating it.
  """
  defaultThreadPriority: Int!

  """
  The external ID of this tier. You can use this field to store your own unique identifier for this tier. This must be unique in your workspace.
  """
  externalId: String
  id: ID!

  """
  If true, this tier will be applied to all threads that do not match any other tier. Only one tier can be the default tier.
  """
  isDefault: Boolean!

  """
  If true, this tier was automatically created based on tenant field values and should not be manually modified.
  """
  isMachineTier: Boolean!
  memberships(after: String, before: String, first: Int, last: Int): TierMembershipConnection!

  """The name of this tier."""
  name: String!
  serviceLevelAgreements: [ServiceLevelAgreement!]!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type TierConnection {
  edges: [TierEdge!]!
  pageInfo: PageInfo!
}

type TierEdge {
  cursor: String!
  node: Tier!
}

input TierIdentifierInput {
  externalId: String
  tierId: ID
}

input TierMemberIdentifierInput {
  companyId: ID
  tenantId: ID
}

union TierMembership = CompanyTierMembership | TenantTierMembership

type TierMembershipConnection {
  edges: [TierMembershipEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type TierMembershipEdge {
  cursor: String!
  node: TierMembership!
}

type TieredRecurringPrice implements RecurringPrice {
  billingIntervalCount: Int!
  billingIntervalUnit: BillingIntervalUnit!
  currency: CurrencyCode!
  tiers: [PriceTier!]!
}

type Time {
  iso8601: String!
}

type TimeSeriesMetric {
  series: [TimeSeriesSeries!]!
  timestamps: [DateTime!]!
}

type TimeSeriesMetricDimension {
  type: TimeSeriesMetricDimensionType!
  value: String!
}

enum TimeSeriesMetricDimensionType {
  COMPANY
  CUSTOMER_GROUP
  LABEL_TYPE
  MESSAGE_SOURCE
  PRIORITY
  TENANT_FIELD
  THREAD_FIELD
  TIER
}

input TimeSeriesMetricFilters {
  csatRating: Int
  csatSurveyId: ID
  userId: ID
}

input TimeSeriesMetricInterval {
  unit: TimeSeriesMetricIntervalUnit
}

enum TimeSeriesMetricIntervalUnit {
  DAY
  HOUR
  MONTH
  QUARTER
  WEEK
  YEAR
}

input TimeSeriesMetricOptions {
  dimension: TimeSeriesMetricDimensionType
  fetchThreadIds: Boolean
  filters: TimeSeriesMetricFilters

  """Defaults to 24 hours ago."""
  from: String
  interval: TimeSeriesMetricInterval
  subDimension: String
  to: String
}

type TimeSeriesSeries {
  dimension: TimeSeriesMetricDimension
  threadIds: [[String]]
  userId: ID
  values: [Float]!
}

type TimelineEntry {
  actor: Actor!
  customerId: ID!
  entry: Entry!
  id: ID!
  llmText: String
  threadId: ID!
  timestamp: DateTime!
}

type TimelineEntryChange {
  changeType: ChangeType!
  timelineEntry: TimelineEntry!
}

type TimelineEntryConnection {
  edges: [TimelineEntryEdge!]!
  pageInfo: PageInfo!
}

type TimelineEntryEdge {
  cursor: String!
  node: TimelineEntry!
}

interface TimelineEventEntry {
  components: [EventComponent!]!
  customerId: ID!
  externalId: ID
  timelineEventId: ID!
  title: String!
}

type Timezone {
  name: String!
}

enum TodoStatusDetail {
  CREATED
  IN_PROGRESS
  NEW_REPLY
  THREAD_DISCUSSION_RESOLVED
  THREAD_LINK_UPDATED
}

type ToggleFeatureEntitlement implements BillingFeatureEntitlement {
  feature: FeatureKey!
  isEntitled: Boolean!
}

input ToggleSlackMessageReactionInput {
  reactionName: String!
  threadId: ID!
  timelineEntryId: ID!
}

type ToggleSlackMessageReactionOutput {
  error: MutationError
}

input ToggleWorkflowRulePublishedInput {
  workflowRuleId: ID!
}

type ToggleWorkflowRulePublishedOutput {
  error: MutationError
  workflowRule: WorkflowRule
}

input UnarchiveLabelTypeInput {
  labelTypeId: ID!
}

type UnarchiveLabelTypeOutput {
  error: MutationError
  labelType: LabelType
}

input UnassignThreadInput {
  threadId: ID!
}

type UnassignThreadOutput {
  error: MutationError
  thread: Thread
}

input UnmarkCustomerAsSpamInput {
  customerId: ID!
}

type UnmarkCustomerAsSpamOutput {
  customer: Customer
  error: MutationError
}

input UpdateActiveBillingRotaInput {
  userIdsToAdd: [ID!]
  userIdsToRemove: [ID!]
}

type UpdateActiveBillingRotaOutput {
  billingRota: BillingRota
  error: MutationError
}

input UpdateApiKeyInput {
  apiKeyId: ID!
  description: String
  permissions: [String!]!
}

type UpdateApiKeyOutput {
  apiKey: ApiKey
  error: MutationError
}

input UpdateAutoresponderInput {
  autoresponderId: ID!
  conditions: [AutoresponderConditionInput!]
  isEnabled: BooleanInput
  markdownContent: OptionalStringInput
  messageSources: [AutoresponderMessageSource!]
  name: StringInput
  order: IntInput
  responseDelaySeconds: IntInput
  textContent: StringInput
}

type UpdateAutoresponderOutput {
  autoresponder: Autoresponder
  error: MutationError
}

input UpdateChatAppInput {
  chatAppId: ID!
  logo: WorkspaceFileInput
  name: StringInput
}

type UpdateChatAppOutput {
  chatApp: ChatApp
  error: MutationError
}

input UpdateCompanyTierInput {
  companyIdentifier: CompanyIdentifierInput!
  tierIdentifier: TierIdentifierInput
}

type UpdateCompanyTierOutput {
  companyTierMembership: CompanyTierMembership
  error: MutationError
}

input UpdateConnectedDiscordChannelInput {
  connectedDiscordChannelId: ID!
  isEnabled: BooleanInput
}

type UpdateConnectedDiscordChannelOutput {
  connectedDiscordChannel: ConnectedDiscordChannel
  error: MutationError
}

input UpdateConnectedSlackChannelInput {
  channelType: ConnectedSlackChannelType
  connectedSlackChannelId: ID!
  isEnabled: BooleanInput
}

type UpdateConnectedSlackChannelOutput {
  connectedSlackChannel: ConnectedSlackChannel
  error: MutationError
}

"""
For constraints and details on the fields see the `CustomerCardConfig` type.
"""
input UpdateCustomerCardConfigInput {
  """
  If provided, will replace the existing API headers. Requires the `customerCardConfigApiDetails:edit` permission.
  """
  apiHeaders: [CustomerCardConfigApiHeaderInput!]

  """
  If provided, will update the API URL. Requires the `customerCardConfigApiDetails:edit` permission.
  """
  apiUrl: StringInput

  """The customer card config to update."""
  customerCardConfigId: ID!

  """If provided, will update the default time to live seconds."""
  defaultTimeToLiveSeconds: IntInput

  """If provided, will update the enabled flag."""
  isEnabled: BooleanInput

  """If provided, will update the key. Keys must be unique in a workspace."""
  key: StringInput

  """If provided, will update the order."""
  order: IntInput

  """If provided, will update the title."""
  title: StringInput
}

type UpdateCustomerCardConfigOutput {
  """The updated customer card config."""
  customerCardConfig: CustomerCardConfig
  error: MutationError
}

input UpdateCustomerCompanyInput {
  """
  The identifier of the company we want to update the customer with. Pass null if you want to remove the company from the customer.
  """
  companyIdentifier: CompanyIdentifierInput

  """The identifier of the customer we want to update the company for."""
  customerId: ID!
}

type UpdateCustomerCompanyOutput {
  customer: Customer
  error: MutationError
}

input UpdateCustomerGroupInput {
  color: StringInput
  customerGroupId: ID!
  externalId: OptionalStringInput
  key: StringInput
  name: StringInput
}

type UpdateCustomerGroupOutput {
  customerGroup: CustomerGroup
  error: MutationError
}

input UpdateCustomerSurveyInput {
  conditions: [CustomerSurveyConditionInput!]
  customerIntervalDays: IntInput
  customerSurveyId: ID!
  isEnabled: BooleanInput
  name: StringInput
  order: Int
  responseDelayMinutes: IntInput
  template: CustomerSurveyTemplateInput
}

type UpdateCustomerSurveyOutput {
  customerSurvey: CustomerSurvey
  error: MutationError
}

input UpdateEscalationPathInput {
  description: String
  escalationPathId: ID!
  name: String
  steps: [EscalationPathStepInput!]
}

type UpdateEscalationPathOutput {
  error: MutationError
  escalationPath: EscalationPath
}

input UpdateGeneratedReplyInput {
  feedback: GeneratedReplyFeedbackInput
  generatedReplyId: ID!
}

type UpdateGeneratedReplyOutput {
  error: MutationError
  generatedReply: GeneratedReply
}

input UpdateHelpCenterArticleGroupInput {
  helpCenterArticleGroupId: ID!
  name: String
}

type UpdateHelpCenterArticleGroupOutput {
  error: MutationError
  helpCenterArticleGroup: HelpCenterArticleGroup
}

input UpdateHelpCenterCustomDomainNameInput {
  customDomainName: OptionalStringInput!
  helpCenterId: ID!
}

type UpdateHelpCenterCustomDomainNameOutput {
  error: MutationError
  helpCenter: HelpCenter
}

input UpdateHelpCenterIndexInput {
  hash: String!
  helpCenterId: ID!
  helpCenterIndex: [HelpCenterIndexItemInput!]!
}

type UpdateHelpCenterIndexOutput {
  error: MutationError
  helpCenterIndex: HelpCenterIndex
}

input UpdateHelpCenterInput {
  access: HelpCenterAccessSettingsInput
  agentAvatarImage: HelpCenterThemedImageInput
  authMechanism: HelpCenterAuthMechanismInput
  bodyCustomJs: StringInput
  color: StringInput
  description: String
  favicon: HelpCenterThemedImageInput
  headCustomJs: StringInput
  helpCenterId: ID!
  internalName: String
  isChatEnabled: Boolean
  logo: HelpCenterThemedImageInput
  portalSettings: HelpCenterPortalSettingsInput
  publicName: String
  socialPreviewImage: WorkspaceFileInput
  subdomain: String
  type: HelpCenterType
}

type UpdateHelpCenterOutput {
  error: MutationError
  helpCenter: HelpCenter
}

input UpdateLabelTypeInput {
  color: OptionalStringInput
  description: OptionalStringInput
  icon: OptionalStringInput
  labelTypeId: ID!
  name: StringInput
}

type UpdateLabelTypeOutput {
  error: MutationError
  labelType: LabelType
}

input UpdateMachineUserInput {
  avatar: WorkspaceFileInput
  description: StringInput
  fullName: StringInput
  machineUserId: ID!
  publicName: StringInput

  """The type of machine user. Defaults to API_USER if not specified."""
  type: MachineUserType
}

type UpdateMachineUserOutput {
  error: MutationError
  machineUser: MachineUser
}

input UpdateMyUserInput {
  fullName: OptionalStringInput
  publicName: OptionalStringInput
}

type UpdateMyUserOutput {
  error: MutationError
  user: User
}

input UpdateSavedThreadsViewInput {
  color: StringInput
  icon: StringInput
  name: StringInput
  savedThreadsViewId: ID!
  threadsFilter: SavedThreadsViewFilterInput
}

type UpdateSavedThreadsViewOutput {
  error: MutationError
  savedThreadsView: SavedThreadsView
}

input UpdateServiceLevelAgreementInput {
  """
  The actions to take when the SLA is about to breach and when it breaches.
  """
  breachActions: [BreachActionInput!]

  """
  This SLA will breach if it does not receive a first response within this many minutes. May only be provided if the service level agreement is a first response time SLA.
  """
  firstResponseTimeMinutes: IntInput

  """
  This SLA will breach if it does not receive a next response within this many minutes. May only be provided if the service level agreement is a next response time SLA.
  """
  nextResponseTimeMinutes: IntInput

  """The ID of the SLA to update."""
  serviceLevelAgreementId: ID!

  """
  This SLA can only be applied to a thread if it has one or all of these label types. If not provided, the filter is not applied.
  """
  threadLabelTypeIdFilter: ServiceLevelAgreementThreadLabelTypeIdFilterInput

  """
  This SLA can only be applied to a thread if it has one of these priority values. If not provided, it defaults to all priorities (0, 1, 2 and 3).
  """
  threadPriorityFilter: IntArrayInput

  """
  If true, the SLA will only be tracked during your workspace's business hours. If false, the SLA will tracked 24/7.
  """
  useBusinessHoursOnly: BooleanInput
}

type UpdateServiceLevelAgreementOutput {
  error: MutationError
  serviceLevelAgreement: ServiceLevelAgreement
}

"""An input provided to the `updateSetting` mutation."""
input UpdateSettingInput {
  """A code for the setting."""
  code: String!

  """A valid scope for the setting code."""
  scope: SettingScopeInput!

  """The setting value."""
  value: SettingValueInput!
}

"""
An output type provided by the `updateSetting` mutation.
Returns the updated setting or an error.
"""
type UpdateSettingOutput {
  error: MutationError

  """The updated setting."""
  setting: Setting
}

input UpdateSnippetInput {
  markdown: StringInput
  name: StringInput

  """Used to group snippets, only accepts alphanumeric characters"""
  path: OptionalStringInput
  snippetId: ID!
  text: StringInput
}

type UpdateSnippetOutput {
  error: MutationError
  snippet: Snippet
}

input UpdateTenantTierInput {
  tenantIdentifier: TenantIdentifierInput!
  tierIdentifier: TierIdentifierInput
}

type UpdateTenantTierOutput {
  error: MutationError
  tenantTierMembership: TenantTierMembership
}

input UpdateThreadEscalationPathInput {
  escalationPathId: ID
  threadId: ID!
}

type UpdateThreadEscalationPathOutput {
  error: MutationError
  thread: Thread
}

input UpdateThreadFieldSchemaInput {
  defaultBooleanValue: OptionalBooleanInput
  defaultStringValue: OptionalStringInput
  dependsOnLabelTypeIds: [ID!]
  dependsOnThreadField: OptionalDependsOnThreadFieldInput
  description: StringInput
  enumValues: [String!]
  isAiAutoFillEnabled: Boolean
  isRequired: Boolean
  label: StringInput
  order: Int
  threadFieldSchemaId: ID!
}

type UpdateThreadFieldSchemaOutput {
  error: MutationError
  threadFieldSchema: ThreadFieldSchema
}

input UpdateThreadTenantInput {
  tenantIdentifier: TenantIdentifierInput
  threadId: ID!
}

type UpdateThreadTenantOutput {
  error: MutationError
  thread: Thread
}

input UpdateThreadTierInput {
  threadId: ID!
  tierIdentifier: TierIdentifierInput
}

type UpdateThreadTierOutput {
  error: MutationError
  thread: Thread
}

input UpdateThreadTitleInput {
  threadId: ID!
  title: String!
}

type UpdateThreadTitleOutput {
  error: MutationError
  thread: Thread
}

input UpdateTierInput {
  color: StringInput
  defaultThreadPriority: IntInput
  externalId: OptionalStringInput
  isDefault: BooleanInput
  name: StringInput
  tierId: ID!
}

type UpdateTierOutput {
  error: MutationError
  tier: Tier
}

input UpdateWebhookTargetInput {
  description: StringInput
  eventSubscriptions: [WebhookTargetEventSubscriptionInput!]
  isEnabled: BooleanInput
  url: StringInput
  version: StringInput
  webhookTargetId: ID!
}

type UpdateWebhookTargetOutput {
  error: MutationError
  webhookTarget: WebhookTarget
}

input UpdateWorkflowRuleInput {
  name: StringInput

  """JSON-encoded payload of the rule definition."""
  payload: StringInput
  workflowRuleId: ID!
}

type UpdateWorkflowRuleOutput {
  error: MutationError
  workflowRule: WorkflowRule
}

input UpdateWorkspaceEmailSettingsInput {
  isEnabled: Boolean!
}

type UpdateWorkspaceEmailSettingsOutput {
  error: MutationError
  workspaceEmailSettings: WorkspaceEmailSettings
}

input UpdateWorkspaceInput {
  domainNames: [String!]
  logo: WorkspaceFileInput
  name: StringInput
  publicName: StringInput
}

type UpdateWorkspaceOutput {
  error: MutationError
  workspace: Workspace
}

type UploadFormData {
  key: String!
  value: String!
}

input UpsertBusinessHoursInput {
  weekDays: BusinessHoursWeekDaysInput
}

type UpsertBusinessHoursOutput {
  businessHours: BusinessHours
  error: MutationError
  result: UpsertResult
}

input UpsertCompanyInput {
  accountOwnerUserId: ID
  contractValue: Int
  domainName: String!
  identifier: CompanyIdentifierInput!
  name: String!
}

type UpsertCompanyOutput {
  company: Company
  error: MutationError
  result: UpsertResult
}

input UpsertCustomerGroupInput {
  color: String!
  externalId: String
  identifier: CustomerGroupIdentifier!
  key: String!
  name: String!
}

type UpsertCustomerGroupOutput {
  customerGroup: CustomerGroup
  error: MutationError
  result: UpsertResult
}

input UpsertCustomerIdentifierInput {
  customerId: ID
  emailAddress: String
  externalId: ID
}

input UpsertCustomerInput {
  identifier: UpsertCustomerIdentifierInput!
  onCreate: UpsertCustomerOnCreateInput!
  onUpdate: UpsertCustomerOnUpdateInput!
}

input UpsertCustomerOnCreateInput {
  customerGroupIdentifiers: [CustomerGroupIdentifier!]
  email: EmailAddressInput!
  externalId: ID
  fullName: String!
  shortName: String
  tenantIdentifiers: [TenantIdentifierInput!]
}

input UpsertCustomerOnUpdateInput {
  email: EmailAddressInput
  externalId: OptionalStringInput
  fullName: StringInput
  shortName: OptionalStringInput
}

type UpsertCustomerOutput {
  customer: Customer
  error: MutationError
  result: UpsertResult
}

input UpsertHelpCenterArticleInput {
  contentHtml: String!
  description: String
  helpCenterArticleGroupId: ID
  helpCenterArticleId: ID
  helpCenterId: ID!
  slug: String
  status: HelpCenterArticleStatus
  title: String!
}

type UpsertHelpCenterArticleOutput {
  error: MutationError
  helpCenterArticle: HelpCenterArticle
}

input UpsertMyEmailSignatureInput {
  markdown: String
  text: String!
}

type UpsertMyEmailSignatureOutput {
  emailSignature: EmailSignature
  error: MutationError
  result: UpsertResult
}

enum UpsertResult {
  CREATED
  NOOP
  UPDATED
}

input UpsertTenantFieldInput {
  arrayValue: [String!]
  booleanValue: Boolean
  dateValue: String
  numberValue: Float
  stringValue: String
  tenantFieldIdentifier: TenantFieldIdentifier!
  type: TenantFieldType!
}

type UpsertTenantFieldOutput {
  error: MutationError
  result: UpsertResult
  tenantField: TenantField
}

input UpsertTenantFieldSchemaInput {
  tenantFieldSchemas: [TenantFieldSchemaInput!]!
}

type UpsertTenantFieldSchemaOutput {
  error: MutationError
  result: UpsertResult
  tenantFieldSchemas: [TenantFieldSchema!]!
}

input UpsertTenantInput {
  externalId: String!
  identifier: TenantIdentifierInput!
  name: String!
  url: OptionalStringInput
}

type UpsertTenantOutput {
  error: MutationError
  result: UpsertResult
  tenant: Tenant
}

input UpsertThreadFieldIdentifier {
  key: String!
  threadId: ID!
}

input UpsertThreadFieldInput {
  booleanValue: Boolean
  identifier: UpsertThreadFieldIdentifier!
  stringValue: String
  type: ThreadFieldSchemaType!
}

type UpsertThreadFieldOutput {
  error: MutationError
  result: UpsertResult
  threadField: ThreadField
}

type User {
  """Additional legacy roles that the user has in the workspace."""
  additionalLegacyRoles: [Role!]!

  """The avatar URL of the user."""
  avatarUrl: String
  createdAt: DateTime!
  createdBy: InternalActor!
  deletedAt: DateTime
  deletedBy: Actor

  """The email associated with this user. Email is unique per user."""
  email: String!

  """The full name e.g. Grace Hopper."""
  fullName: String!
  id: ID!
  isDeleted: Boolean!

  """The labels associated with this user."""
  labels: [Label!]!

  """A short name for use in UI e.g. Grace."""
  publicName: String!

  """The role of the user in the workspace."""
  role: Role

  """(Legacy) Retrieve roles for a specific workspace + user."""
  roles: [Role!]!

  """Connected slack users to this Plain account."""
  slackIdentities: [SlackUserIdentity!]!
  status: UserStatus!
  statusChangedAt: DateTime!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type UserAccount {
  """The email associated with this user. Email is unique per user."""
  email: String!

  """The full name e.g. Grace Hopper."""
  fullName: String!
  id: ID!

  """A short name for use in UI e.g. Grace."""
  publicName: String!
}

type UserActor {
  user: User!
  userId: ID!
}

type UserAuthDiscordChannelInstallationInfo {
  installationUrl: String!
}

type UserAuthDiscordChannelIntegration {
  createdAt: DateTime!
  createdBy: InternalActor!
  discordGlobalName: String
  discordGuildId: String!
  discordUserEmail: String!
  discordUserId: String!
  discordUsername: String!
  id: ID!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type UserAuthDiscordChannelIntegrationConnection {
  edges: [UserAuthDiscordChannelIntegrationEdge!]!
  pageInfo: PageInfo!
}

type UserAuthDiscordChannelIntegrationEdge {
  cursor: String!
  node: UserAuthDiscordChannelIntegration!
}

type UserAuthSlackInstallationInfo {
  installationUrl: String!
}

type UserAuthSlackIntegration {
  createdAt: DateTime!
  createdBy: InternalActor!
  integrationId: ID!
  isReinstallRequired: Boolean!
  slackTeamId: String!
  slackTeamName: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type UserChange {
  changeType: ChangeType!
  user: User!
}

type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}

type UserEdge {
  cursor: String!
  node: User!
}

type UserEmailActor {
  user: User!
  userId: ID!
}

type UserLinearInstallationInfo {
  installationUrl: String!
}

type UserLinearIntegration {
  createdAt: DateTime!
  createdBy: InternalActor!
  integrationId: ID!
  linearOrganisationId: ID!
  linearOrganisationName: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type UserMSTeamsInstallationInfo {
  installationUrl: String
}

type UserMSTeamsIntegration {
  createdAt: DateTime!
  createdBy: InternalActor!
  id: ID!
  isReinstallRequired: Boolean!
  msTeamsPreferredUsername: String
  msTeamsTenantId: ID!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type UserSlackInstallationInfo {
  installationUrl: String!
}

type UserSlackIntegration {
  createdAt: DateTime!
  createdBy: InternalActor!
  integrationId: ID!
  isReinstallRequired: Boolean!
  slackTeamName: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

enum UserStatus {
  BREAK
  OFFLINE
  ONLINE
}

input UsersFilter {
  isAssignableToCustomer: Boolean @deprecated(reason: "Use isAssignableToThread instead")
  isAssignableToThread: Boolean
}

input VerifyHelpCenterCustomDomainNameInput {
  helpCenterId: ID!
}

type VerifyHelpCenterCustomDomainNameOutput {
  error: MutationError
  helpCenter: HelpCenter
}

type VerifyWorkspaceEmailDnsSettingsOutput {
  error: MutationError
  workspaceEmailDomainSettings: WorkspaceEmailDomainSettings
}

input VerifyWorkspaceEmailForwardingSettingsInput {
  isForwardingConfigured: Boolean!
}

type VerifyWorkspaceEmailForwardingSettingsOutput {
  error: MutationError
  workspaceEmailDomainSettings: WorkspaceEmailDomainSettings
}

type WebhookTarget {
  createdAt: DateTime!
  createdBy: InternalActor!
  description: String!
  eventSubscriptions: [WebhookTargetEventSubscription!]!
  id: ID!
  isEnabled: Boolean!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  url: String!
  version: String!
}

type WebhookTargetConnection {
  edges: [WebhookTargetEdge!]!
  pageInfo: PageInfo!
}

type WebhookTargetEdge {
  cursor: String!
  node: WebhookTarget!
}

type WebhookTargetEventSubscription {
  eventType: String!
}

input WebhookTargetEventSubscriptionInput {
  eventType: String!
}

type WebhookVersion {
  isDeprecated: Boolean!
  isLatest: Boolean!
  version: String!
}

type WebhookVersionConnection {
  edges: [WebhookVersionEdge!]!
  pageInfo: PageInfo!
}

type WebhookVersionEdge {
  cursor: String!
  node: WebhookVersion!
}

enum WeekDay {
  FRIDAY
  MONDAY
  SATURDAY
  SUNDAY
  THURSDAY
  TUESDAY
  WEDNESDAY
}

type WorkflowRule {
  createdAt: DateTime!
  createdBy: InternalActor!
  id: ID!
  name: String!

  """JSON-encoded payload of the rule definition."""
  payload: String!
  publishedAt: DateTime
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type WorkflowRuleConnection {
  edges: [WorkflowRuleEdge!]!
  pageInfo: PageInfo!
}

type WorkflowRuleEdge {
  cursor: String!
  node: WorkflowRule!
}

input WorkosConnectAuthMechanismInput {
  apiHost: String!
  appClientId: String!
  appSecret: String!
}

type Workspace {
  createdAt: DateTime!
  createdBy: InternalActor!
  domainName: String @deprecated(reason: "Use domainNames instead")
  domainNames: [String!]!
  id: ID!
  isDemoWorkspace: Boolean!
  logo: WorkspaceFile
  name: String!
  publicName: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  workspaceChatSettings: WorkspaceChatSettings!
  workspaceEmailSettings: WorkspaceEmailSettings!
}

type WorkspaceChatSettings {
  isEnabled: Boolean!
}

type WorkspaceConnection {
  edges: [WorkspaceEdge!]!
  pageInfo: PageInfo!
}

type WorkspaceDiscordChannelInstallationInfo {
  installationUrl: String!
}

type WorkspaceDiscordChannelIntegration {
  createdAt: DateTime!
  createdBy: InternalActor!
  discordGuildId: String!
  discordGuildName: String!
  id: ID!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type WorkspaceDiscordChannelIntegrationConnection {
  edges: [WorkspaceDiscordChannelIntegrationEdge!]!
  pageInfo: PageInfo!
}

type WorkspaceDiscordChannelIntegrationEdge {
  cursor: String!
  node: WorkspaceDiscordChannelIntegration!
}

type WorkspaceDiscordIntegration {
  createdAt: DateTime!
  createdBy: InternalActor!
  integrationId: ID!
  name: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  webhookUrl: String!
}

type WorkspaceDiscordIntegrationConnection {
  edges: [WorkspaceDiscordIntegrationEdge!]!
  pageInfo: PageInfo!
}

type WorkspaceDiscordIntegrationEdge {
  cursor: String!
  node: WorkspaceDiscordIntegration!
}

type WorkspaceEdge {
  cursor: String!
  node: Workspace!
}

type WorkspaceEmailDomainSettings {
  """
  The list of alternate email addresses that can be used to send emails to and from the workspace.
  Limited to 5.
  
  e.g. [info@plain.com, help@plain.com].
  """
  alternateSupportEmailAddresses: [String!]!
  dkimDnsRecord: DnsRecord!
  domainName: String!
  inboundForwardingEmail: String!
  isDomainConfigured: Boolean!
  isForwardingConfigured: Boolean!
  returnPathDnsRecord: DnsRecord!
  supportEmailAddress: String!
}

type WorkspaceEmailSettings {
  bccEmail: String
  isEnabled: Boolean!
  workspaceEmailDomainSettings: WorkspaceEmailDomainSettings
}

type WorkspaceFile {
  createdAt: DateTime!
  createdBy: InternalActor!

  """This URL will only be available after the file has been uploaded."""
  downloadUrl: WorkspaceFileDownloadUrl
  fileExtension: String
  fileMimeType: String!
  fileName: String!
  fileSize: FileSize!
  id: ID!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  visibility: WorkspaceFileVisibility!
}

type WorkspaceFileDownloadUrl {
  downloadUrl: String!

  """
  The time when the download URL will expire. Only set when visibility of the workspace file is PRIVATE.
  """
  expiresAt: DateTime
}

input WorkspaceFileInput {
  workspaceFileId: ID
}

type WorkspaceFileUploadUrl {
  expiresAt: DateTime!
  uploadFormData: [UploadFormData!]!
  uploadFormUrl: String!
  workspaceFile: WorkspaceFile!
}

enum WorkspaceFileVisibility {
  PRIVATE
  PUBLIC
}

type WorkspaceHmac {
  createdAt: DateTime!
  createdBy: InternalActor!
  hmacSecret: String
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type WorkspaceInvite {
  """When the invite was created."""
  createdAt: DateTime!

  """Who sent this invite."""
  createdBy: InternalActor!

  """The email that is being invited."""
  email: String!
  id: ID!

  """Whether the person has accepted the invite."""
  isAccepted: Boolean!

  """
  The role that the invite will assign on workspace joining. This will replace the roles field.
  """
  role: Role

  """The roles that the invite will assign on workspace joining."""
  roles: [Role!]!

  """When the invite was updated."""
  updatedAt: DateTime!

  """Who updated this invite."""
  updatedBy: InternalActor!

  """Whether the user would be assigned a billing rota seat upon joining."""
  usingBillingRotaSeat: Boolean!

  """The workspace they are being invited to."""
  workspace: Workspace!
}

type WorkspaceInviteConnection {
  edges: [WorkspaceInviteEdge!]!
  pageInfo: PageInfo!
}

type WorkspaceInviteEdge {
  cursor: String!
  node: WorkspaceInvite!
}

type WorkspaceMSTeamsInstallationInfo {
  installationUrl: String!
}

type WorkspaceMSTeamsIntegration {
  createdAt: DateTime!
  createdBy: InternalActor!
  id: ID!
  isReinstallRequired: Boolean!
  msTeamsTenantId: ID!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type WorkspaceSlackChannelInstallationInfo {
  installationUrl: String!
}

type WorkspaceSlackChannelIntegration {
  createdAt: DateTime!
  createdBy: InternalActor!
  integrationId: ID!
  isReinstallRequired: Boolean!
  slackTeamId: String!
  slackTeamImageUrl68px: String
  slackTeamName: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type WorkspaceSlackChannelIntegrationConnection {
  edges: [WorkspaceSlackChannelIntegrationEdge!]!
  pageInfo: PageInfo!
}

type WorkspaceSlackChannelIntegrationEdge {
  cursor: String!
  node: WorkspaceSlackChannelIntegration!
}

type WorkspaceSlackInstallationInfo {
  installationUrl: String!
}

type WorkspaceSlackIntegration {
  createdAt: DateTime!
  createdBy: InternalActor!
  integrationId: ID!
  isReinstallRequired: Boolean!
  slackChannelName: String!
  slackTeamImageUrl68px: String
  slackTeamName: String!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type WorkspaceSlackIntegrationConnection {
  edges: [WorkspaceSlackIntegrationEdge!]!
  pageInfo: PageInfo!
}

type WorkspaceSlackIntegrationEdge {
  cursor: String!
  node: WorkspaceSlackIntegration!
}